# 2. 路由

>摘要: 主要参考[芋道源码](http://www.iocoder.cn),此笔记主要参考上述原创地址学习并添加个人学习理解.

## 2.1 RouteDefinitionLocator概览

### 2.1.1 概述

* 路由相关的组件 RouteDefinitionLocator / RouteLocator 的初始化

![image](http://spring-cloud-gateway-1252032169.cossh.myqcloud.com/routeDefinitionLocator.png)

* **RouteDefinitionLocator** 负责读取路由配置( org.springframework.cloud.gateway.route.RouteDefinition ) 。从上图中我们可以看到，RouteDefinitionLocator 接口有四种实现 ：
  * **PropertiesRouteDefinitionLocator** ，从配置文件( 例如，YML / Properties 等 ) 读取。
  * **RouteDefinitionRepository** ，从存储器( 例如，内存 / Redis / MySQL 等 )读取。
  * **DiscoveryClientRouteDefinitionLocator** ，从注册中心( 例如，Eureka / Consul / Zookeeper / Etcd 等 )读取。
  * **CompositeRouteDefinitionLocator** ，组合多种 RouteDefinitionLocator 的实现，为 RouteDefinitionRouteLocator 提供统一入口。
  * 另外，**CachingRouteDefinitionLocator** 也是 RouteDefinitionLocator 的实现类，已经被 CachingRouteLocator 取代。
* **RouteLocator** 可以直接自定义路由( org.springframework.cloud.gateway.route.Route ) ，也可以通过 RouteDefinitionRouteLocator 获取 RouteDefinition ，并转换成 Route 。
* 重要，对于上层调用者 RoutePredicateHandlerMapping ，使用的是 RouteLocator 和 Route 。而 RouteDefinitionLocator 和 RouteDefinition **用于通过配置定义路由**。那么自定义 RouteLocator 呢？**通过代码定义路由**。

### 2.1.2 RouteDefinition

* org.springframework.cloud.gateway.route.RouteDefinition ，路由定义。

```java

@Validated
public class RouteDefinition {
    @NotEmpty
    private String id = UUID.randomUUID().toString();
    /**
     * 谓语定义数组
     */
    @NotEmpty
    @Valid
    private List<PredicateDefinition> predicates = new ArrayList<>();
    /**
     * 过滤器定义数组
     */
    @Valid
    private List<FilterDefinition> filters = new ArrayList<>();
    /**
     * 路由向的 URI
     */
    @NotNull
    private URI uri;
    /**
     * 顺序
     */
    private int order = 0;
}

```

* **id** 属性，ID 编号，唯一。
* **predicates** 属性，谓语定义数组。请求通过 predicates 判断是否匹配。在 Route 里，PredicateDefinition 转换成 Predicate 。
* **filters** 属性，过滤器定义数组。在 Route 里，FilterDefinition 转换成 GatewayFilter 。
* **uri** 属性，路由向的 URI 。
* **order** 属性，顺序。当请求匹配到多个路由时，使用顺序小的。

![image](http://spring-cloud-gateway-1252032169.file.myqcloud.com/predicates.png)

* RouteDefinition提供text字符串创建对象

```java

/**
 * 根据 text 创建 RouteDefinition
 *
 * @param text 格式 ${id}=${uri},${predicates[0]},${predicates[1]}...${predicates[n]}
 *             例如 route001=http://127.0.0.1,Host=**.addrequestparameter.org,Path=/get
 */
public RouteDefinition(String text) {
    int eqIdx = text.indexOf("=");
    if (eqIdx <= 0) {
        throw new ValidationException("Unable to parse RouteDefinition text '" + text + "'" +
                ", must be of the form name=value");
    }
    // id
    setId(text.substring(0, eqIdx));
    // predicates
    String[] args = tokenizeToStringArray(text.substring(eqIdx+1), ",");
    // uri
    setUri(URI.create(args[0]));
    for (int i=1; i < args.length; i++) {
        this.predicates.add(new PredicateDefinition(args[i]));
    }
}

```

* **text** 参数，格式为 ${id}=${uri},${predicates[0]},${predicates[1]}...${predicates[n]} 。举个例子, ```"route001=http://127.0.0.1,Host=**.addrequestparameter.org,Path=/get"``` 。创建的 RouteDefinition 如下图 ：
* **filters** 属性，需要通过调用 RouteDefinition#setFilters(filters) 方法进行设置。
* **order** 属性，需要通过调用 RouteDefinition#setOrder(order) 方法进行设置。
* **predicates** 属性，支持解析，但是如果此处单个 PredicateDefinition 的 args[i] 存在逗号( , ) ，会被错误的分隔，例如说，"Query=foo,bz" 。

![image](http://spring-cloud-gateway-1252032169.cossh.myqcloud.com/new%20RouteDefinition.png)

### 2.1.3 PredicateDefinition

```org.springframework.cloud.gateway.handler.predicate.PredicateDefinition``` ，谓语定义。请求通过 predicates 判断是否匹配。

```java

@Validated
public class PredicateDefinition {
    /**
     * 谓语定义名字
     */
    @NotNull
    private String name;
    /**
     * 参数数组
     */
    private Map<String, String> args = new LinkedHashMap<>();
}

```

* ```name```属性，谓语定义名字。通过 name 对应到```org.springframework.cloud.gateway.handler.predicate.RoutePredicateFactory``` 的实现类。例如说，name=Query 对应到 QueryRoutePredicateFactory 。
* ```args```属性，参数数组。例如，```name=Host / args={"_genkey_0" : "baidu.cn"}```，匹配请求的```hostname```为```baidu.cn```。
* PredicateDefinition 提供 text 字符串创建对象

```java

/**
 *根据 text 创建 PredicateDefinition
 *
 * @param text 格式 ${name}=${args[0]},${args[1]}...${args[n]}
 *             例如 Host=iocoder.cn
 */
public PredicateDefinition(String text) {
    int eqIdx = text.indexOf("=");
    if (eqIdx <= 0) {
        throw new ValidationException("Unable to parse PredicateDefinition text '" + text + "'" +
                ", must be of the form name=value");
    }
    // name
    setName(text.substring(0, eqIdx));
    // args
    String[] args = tokenizeToStringArray(text.substring(eqIdx+1), ",");
    for (int i=0; i < args.length; i++) {
        this.args.put(NameUtils.generateName(i), args[i]);
    }
}

```

### 2.1.4 FilterDefinition

* FilterDefinition 和 PredicateDefinition 的代码实现上基本一致,org.springframework.cloud.gateway.filter.FilterDefinition ，过滤器定义。
* ```name``` 属性，过滤器定义名字。通过 name 对应到 ```org.springframework.cloud.gateway.filter.factory.GatewayFilterFactory``` 的实现类。例如说，name=AddRequestParameter 对应到 AddRequestParameterGatewayFilterFactory 。
* ```args``` 属性，参数数组。例如，```name=AddRequestParameter / args={"_genkey_0": "foo", "_genkey_1": "bar"}``` ，添加请求参数 foo 为 bar 。

```java

/**
 *根据 text 创建 FilterDefinition
 *
 * @param text 格式 ${name}=${args[0]},${args[1]}...${args[n]}
 *             例如 AddRequestParameter=foo, bar
 */
public FilterDefinition(String text) {
    int eqIdx = text.indexOf("=");
    if (eqIdx <= 0) {
        setName(text);
        return;
    }
    // name
    setName(text.substring(0, eqIdx));
    // args
    String[] args = tokenizeToStringArray(text.substring(eqIdx+1), ",");
    for (int i=0; i < args.length; i++) {
        this.args.put(NameUtils.generateName(i), args[i]);
    }
}

```

### 2.1.5 RouteDefinitionLocator

```org.springframework.cloud.gateway.route.RouteDefinitionLocator```，路由定义定位器接口，定义获得路由定义数组的方法。

```java

public interface RouteDefinitionLocator {
    Flux<RouteDefinition> getRouteDefinitions();
}

```

* **CompositeRouteDefinitionLocator**:组合多种 RouteDefinitionLocator 的实现，为 RouteDefinitionRouteLocator 提供统一入口。

```java

public class CompositeRouteDefinitionLocator implements RouteDefinitionLocator {
    /**
     * RouteDefinitionLocator 数组
     */
    private final Flux<RouteDefinitionLocator> delegates;
    public CompositeRouteDefinitionLocator(Flux<RouteDefinitionLocator> delegates) {
        this.delegates = delegates;
    }
    @Override
    public Flux<RouteDefinition> getRouteDefinitions() {
        return this.delegates.flatMap(RouteDefinitionLocator::getRouteDefinitions);
    }
}

```

* ```#getRouteDefinitions()```方法，提供统一方法，将组合的 delegates 的路由定义全部返回。

* 接下来会进行一系列转换
  * RouteDefinition => Route
  * PredicateDefinition => Predication
  * FilterDefinition => GatewayFilter

## 2.2 PropertiesRouteDefinitionLocator 配置文件

![image](http://spring-cloud-gateway-1252032169.cossh.myqcloud.com/2-01.jpeg)

### 2.2.1 PropertiesRouteDefinitionLocator

```org.springframework.cloud.gateway.config.PropertiesRouteDefinitionLocator``` ，从配置文件( 例如，YML / Properties 等 ) 读取路由配置。

```java

public class PropertiesRouteDefinitionLocator implements RouteDefinitionLocator {
    private final GatewayProperties properties;
    public PropertiesRouteDefinitionLocator(GatewayProperties properties) {
        this.properties = properties;
    }
    @Override
    public Flux<RouteDefinition> getRouteDefinitions() {
        return Flux.fromIterable(this.properties.getRoutes());
    }
}

```

* ```#getRouteDefinitions()``` 方法，从 GatewayProperties 获取路由配置数组。

### 2.2.2 GatewayProperties

* org.springframework.cloud.gateway.config.GatewayProperties ，从配置文件读取 ：
  * 路由配置
  * 默认过滤器配置。当 RouteDefinition => Route 时，会将过滤器配置添加到每个 Route 。

```java

@ConfigurationProperties("spring.cloud.gateway")
@Validated
public class GatewayProperties {
    /**
     * List of Routes
     */
    @NotNull
    @Valid
    private List<RouteDefinition> routes = new ArrayList<>();
    /**
     * List of filter definitions that are applied to every route.
     */
    private List<FilterDefinition> defaultFilters = loadDefaults();
    private ArrayList<FilterDefinition> loadDefaults() {
        ArrayList<FilterDefinition> defaults = new ArrayList<>();
        FilterDefinition definition = new FilterDefinition();
        definition.setName(normalizeFilterName(RemoveNonProxyHeadersGatewayFilterFactory.class));
        defaults.add(definition);
        return defaults;
    }
}

```

* routes 属性，路由配置。通过 spring.cloud.gateway.routes 配置。

```yaml

spring:
  cloud:
    gateway:
      routes:
      # =====================================
      - host_example_to_httpbin=${test.uri}, Host=**.example.org
      # =====================================
      - id: host_foo_path_headers_to_httpbin
        uri: ${test.uri}
        predicates:
        - Host=**.foo.org
        - Path=/headers
        - Method=GET
        - Header=X-Request-Id, \d+
        - Query=foo, ba.
        - Query=baz
        - Cookie=chocolate, ch.p
        - After=1900-01-20T17:42:47.789-07:00[America/Denver]
        filters:
        - AddResponseHeader=X-Response-Foo, Bar
      # =====================================
      - id: add_request_header_test
        uri: ${test.uri}
        predicates:
        - Host=**.addrequestheader.org
        - Path=/headers
        filters:
        - AddRequestHeader=X-Request-Foo, Bar

```

* defaultFilters 属性，默认过滤器配置。通过 spring.cloud.gateway.default-filters 配置。

```yaml

spring:
  cloud:
    gateway:
      default-filters:
      - AddResponseHeader=X-Response-Default-Foo, Default-Bar
      - PrefixPath=/httpbin

```

## 2.3 RouteDefinitionRepository 存储器

![image](http://spring-cloud-gateway-1252032169.cossh.myqcloud.com/2-01.jpeg)
![image](http://spring-cloud-gateway-1252032169.cossh.myqcloud.com/2-02.jpeg)

### 2.3.1 RouteDefinitionWriter

```org.springframework.cloud.gateway.route.RouteDefinitionWriter``` ，路由配置写入接口。该接口定义了保存与删除两个方法

```java

public interface RouteDefinitionWriter {
    /**
     * 保存路由配置
     *
     * @param route 路由配置
     * @return Mono<Void>
     */
    Mono<Void> save(Mono<RouteDefinition> route);
    /**
     * 删除路由配置
     *
     * @param routeId 路由编号
     * @return Mono<Void>
     */
    Mono<Void> delete(Mono<String> routeId);
}

```

### 2.3.2 RouteDefinitionRepository

```org.springframework.cloud.gateway.route.RouteDefinitionRepository``` ，存储器 RouteDefinitionLocator 接口

```java

public interface RouteDefinitionRepository extends RouteDefinitionLocator, RouteDefinitionWriter {
}

```

* 继承 RouteDefinitionLocator 接口。
* 继承 RouteDefinitionWriter 接口。

* 通过实现该接口，实现从存储器( 例如，内存 / Redis / MySQL 等 )读取、保存、删除路由配置。
* 目前 Spring Cloud Gateway 实现了基于内存为存储器的 InMemoryRouteDefinitionRepository 。

### 2.3.3 InMemoryRouteDefinitionRepository

```org.springframework.cloud.gateway.route.InMemoryRouteDefinitionRepository``` ，基于内存为存储器的 RouteDefinitionLocator.

```java

public class InMemoryRouteDefinitionRepository implements RouteDefinitionRepository {
    /**
     * 路由配置映射
     * key ：路由编号 {@link RouteDefinition#id}
     */
    private final Map<String, RouteDefinition> routes = synchronizedMap(new LinkedHashMap<String, RouteDefinition>());
    @Override
    public Mono<Void> save(Mono<RouteDefinition> route) {
        return route.flatMap( r -> {
            routes.put(r.getId(), r);
            return Mono.empty();
        });
    }
    @Override
    public Mono<Void> delete(Mono<String> routeId) {
        return routeId.flatMap(id -> {
            if (routes.containsKey(id)) {
                routes.remove(id);
                return Mono.empty();
            }
            return Mono.error(new NotFoundException("RouteDefinition not found: "+routeId));
        });
    }
    @Override
    public Flux<RouteDefinition> getRouteDefinitions() {
        return Flux.fromIterable(routes.values());
    }
}

```

* InMemoryRouteDefinitionRepository#getRouteDefinitions() 方法的调用，我们已经在 CompositeRouteDefinitionLocator 看到。
* InMemoryRouteDefinitionRepository#save() / InMemoryRouteDefinitionRepository#delete() 方法，下面在 GatewayWebfluxEndpoint 可以看到。

### 2.3.4 GatewayWebfluxEndpoint

```org.springframework.cloud.gateway.actuate.GatewayWebfluxEndpoint``` ，提供管理网关的 HTTP API 。

```java

@RestController
@RequestMapping("${management.context-path:/application}/gateway")
public class GatewayWebfluxEndpoint implements ApplicationEventPublisherAware {
    /**
     * 存储器 RouteDefinitionLocator 对象
     */
    private RouteDefinitionWriter routeDefinitionWriter;
    // ... 省略代码
}

```

* 从注解 @RestController 我们可以得知，GatewayWebfluxEndpoint 是一个 Controller 。GatewayWebfluxEndpoint 有两个 HTTP API 调用了 RouteDefinitionWriter 的两个方法。
* POST "/routes/{id}" ，保存路由配置

```java

@PostMapping("/routes/{id}")
@SuppressWarnings("unchecked")
public Mono<ResponseEntity<Void>> save(@PathVariable String id, @RequestBody Mono<RouteDefinition> route) {
    return this.routeDefinitionWriter.save(route.map(r ->  { // 设置 ID
        r.setId(id);
        log.debug("Saving route: " + route);
        return r;
    })).then(Mono.defer(() -> // status ：201 ，创建成功。参见 HTTP 规范 ：https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201
        Mono.just(ResponseEntity.created(URI.create("/routes/"+id)).build())
    ));
}

http POST :8080/application/gateway/routes/apiaddreqhead uri=http://httpbin.org:80 predicates:=’[“Host=**.apiaddrequestheader.org”, “Path=/headers”]’ filters:=’[“AddRequestHeader=X-Request-ApiFoo, ApiBar”]’

```

* DELETE "/routes/{id}" ，删除路由配置

```java

@DeleteMapping("/routes/{id}")
public Mono<ResponseEntity<Object>> delete(@PathVariable String id) {
    return this.routeDefinitionWriter.delete(Mono.just(id))
            .then(Mono.defer(() -> Mono.just(ResponseEntity.ok().build()))) // 删除成功
            .onErrorResume(t -> t instanceof NotFoundException, t -> Mono.just(ResponseEntity.notFound().build())); // 删除失败
}

```

### 2.3.5 自定义 RouteDefinitionRepository

* 使用 InMemoryRouteDefinitionRepository 来维护 RouteDefinition 信息，在网关实例重启或者崩溃后，RouteDefinition 就会丢失。此时我们可以实现 RouteDefinitionRepository 接口，以实现例如 MySQLRouteDefinitionRepository 。
* 通过类似 MySQL 等**持久化、可共享**的存储器，也可以带来 Spring Cloud Gateway 实例集群获得一致的、相同的 RouteDefinition 信息。
* 另外，我们看到 RouteDefinitionRepository 初始化的代码如下

```java

// GatewayAutoConfiguration.java
@Bean // 4.2
@ConditionalOnMissingBean(RouteDefinitionRepository.class)
public InMemoryRouteDefinitionRepository inMemoryRouteDefinitionRepository() {
    return new InMemoryRouteDefinitionRepository();
}

```

* 注解 @ConditionalOnMissingBean(RouteDefinitionRepository.class) ，当不存在 RouteDefinitionRepository 的 Bean 对象时，初始化 InMemoryRouteDefinitionRepository 。也就是说，我们可以初始化自定义的 RouteDefinitionRepository 以“注入” 。

## 2.4 DiscoveryClientRouteDefinitionLocator 注册中心

### 2.4.1 概述

```DiscoveryClientRouteDefinitionLocator```通过调用```org.springframework.cloud.client.discovery.DiscoveryClient```获取注册在注册中心的服务列表，生成对应的 RouteDefinition 数组

### 2.4.2 环境搭建

* 以 Eureka 为注册中心，讲解下如何配置 DiscoveryClientRouteDefinitionLocator 。第一步，以 spring-cloud-gateway-sample 项目为基础，在 pom.xml 文件添加依赖库

```xml

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-commons</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-eureka</artifactId>
    <version>2.0.0.M1</version>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </exclusion>
    </exclusions>
</dependency>

```

>注意，需要排除 spring-boot-starter-web 的依赖，避免和 Spring Cloud Gateway 依赖的 spring-boot-starter-webflux 冲突。

* 第二步，在 application.yml 添加 Eureka 相关配置 。

```yaml

spring:
  application:
      name: clsaa-gateway
eureka:
  instance:
    leaseRenewalIntervalInSeconds: 10
    leaseExpirationDurationInSeconds: 30
  client:
    serviceUrl:
      defaultZone: http://eureka.didispace.com/eureka/

```

* 第三步，在 org.springframework.cloud.gateway.sample.GatewaySampleApplication 类里，添加 RouteDefinitionLocator Bean 配置。

```java

@EnableDiscoveryClient // {@link DiscoveryClientRouteDefinitionLocator}
public class GatewaySampleApplication {

    // ... 省略其他代码
    @Bean
    public RouteDefinitionLocator discoveryClientRouteDefinitionLocator(DiscoveryClient discoveryClient) {
        return new DiscoveryClientRouteDefinitionLocator(discoveryClient);
    }
}

```

* 第四步，启动一个注册在 Eureka 的应用服务。机智如你，这里我就不啰嗦落。

* 第五步，在 DiscoveryClientRouteDefinitionLocator 的 #getRouteDefinitions() 方法打断点，调试启动 spring-cloud-gateway-sample 。

### 2.4.3 DiscoveryClientRouteDefinitionLocator

* ```org.springframework.cloud.gateway.discovery.DiscoveryClientRouteDefinitionLocator``` ，通过调用 DiscoveryClient 获取注册在注册中心的服务列表，生成对应的 RouteDefinition 数组。

```java

 1: public class DiscoveryClientRouteDefinitionLocator implements RouteDefinitionLocator {
 2:
 3:     private final DiscoveryClient discoveryClient;
 4:     private final String routeIdPrefix;
 5:
 6:     public DiscoveryClientRouteDefinitionLocator(DiscoveryClient discoveryClient) {
 7:         this.discoveryClient = discoveryClient;
 8:         this.routeIdPrefix = this.discoveryClient.getClass().getSimpleName() + "_";
 9:     }
10:
11:     @Override
12:     public Flux<RouteDefinition> getRouteDefinitions() {
13:         return Flux.fromIterable(discoveryClient.getServices())
14:                 .map(serviceId -> {
15:                     RouteDefinition routeDefinition = new RouteDefinition();
16:                     // 设置 ID
17:                     routeDefinition.setId(this.routeIdPrefix + serviceId);
18:                     // 设置 URI
19:                     routeDefinition.setUri(URI.create("lb://" + serviceId));
20:
21:                     // add a predicate that matches the url at /serviceId
22:                     /*PredicateDefinition barePredicate = new PredicateDefinition();
23:                     barePredicate.setName(normalizePredicateName(PathRoutePredicateFactory.class));
24:                     barePredicate.addArg(PATTERN_KEY, "/" + serviceId);
25:                     routeDefinition.getPredicates().add(barePredicate);*/
26:
27:                     // 添加 Path 匹配断言
28:                     // add a predicate that matches the url at /serviceId/**
29:                     PredicateDefinition subPredicate = new PredicateDefinition();
30:                     subPredicate.setName(normalizePredicateName(PathRoutePredicateFactory.class));
31:                     subPredicate.addArg(PATTERN_KEY, "/" + serviceId + "/**");
32:                     routeDefinition.getPredicates().add(subPredicate);
33:
34:                     //TODO: support for other default predicates
35:
36:                     // 添加 Path 重写过滤器
37:                     // add a filter that removes /serviceId by default
38:                     FilterDefinition filter = new FilterDefinition();
39:                     filter.setName(normalizeFilterName(RewritePathGatewayFilterFactory.class));
40:                     String regex = "/" + serviceId + "/(?<remaining>.*)";
41:                     String replacement = "/${remaining}";
42:                     filter.addArg(REGEXP_KEY, regex);
43:                     filter.addArg(REPLACEMENT_KEY, replacement);
44:                     routeDefinition.getFilters().add(filter);
45:
46:                     //TODO: support for default filters
47:
48:                     return routeDefinition;
49:                 });
50:     }
51: }

```

* discoveryClient 属性，注册发现客户端，用于向注册中心发起请求。
* routeIdPrefix 属性，路由配置编号前缀，以 DiscoveryClient 类名 + _ 。
* 第 13 行 ：调用 discoveryClient 获取注册在注册中心的服务列表。
* 第 14 行 ：遍历服务列表，生成对应的 RouteDefinition 数组。
* 第 16 行 ：设置 RouteDefinition.id 。
* 第 18 行 ：设置 RouteDefinition.uri ，格式为 lb://${serviceId} 。在 LoadBalancerClientFilter 会根据 lb:// 前缀过滤处理，负载均衡，选择最终调用的服务地址，在 《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.4) 之 LoadBalancerClientFilter 负载均衡》 详细解析。
* 第 27 至 32 行 ：使用 PathRoutePredicateFactory 创建 Path 匹配断言。
  * 例如服务的 serviceId = spring.application.name = juejin-sample ，通过网关```http://${gateway}/${serviceId}/some_api访问服务http://some_api```
  * PathRoutePredicateFactory 在 《Spring-Cloud-Gateway 源码解析 —— 处理器 (3.1) 之 RoutePredicateFactory 路由谓语工厂》「10. PathRoutePredicateFactory」 有详细解析。
* 第 36 至 44 行 ：使用 RewritePathGatewayFilterFactory 创建重写网关过滤器，用于移除请求路径里的 /${serviceId} 。如果不移除，最终请求不到服务。RewritePathGatewayFilterFactory 在 《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.2) 之 GatewayFilterFactory 过滤器工厂》「4.1 RewritePathGatewayFilterFactory」 有详细解析。
* 第 48 行 ：返回路由定义 RouteDefinition 

![image](http://spring-cloud-gateway-1252032169.cossh.myqcloud.com/2-04.png)

### 2.4.4 其他

* RoutePredicateHandlerMapping 使用 CachingRouteLocator 来获取 Route 信息。在 Spring Cloud Gateway 启动后，如果有新加入的服务，则需要刷新 CachingRouteLocator 缓存。
* 这里有一点需要注意下 ：新加入的服务，指的是新的 serviceId ，而不是原有服务新增的实例。
* 可以写一个定时任务，间隔调用 DiscoveryClient 获取服务列表，若发现变化，刷新 CachingRouteLocator 缓存。

## 2.5 RouteLocator

![image](http://spring-cloud-gateway-1252032169.cossh.myqcloud.com/routeDefinitionLocator.png)

* RouteLocator 可以直接自定义路由( org.springframework.cloud.gateway.route.Route ) ，也可以通过 RouteDefinitionRouteLocator 获取 RouteDefinition ，并转换成 Route 。
* RoutePredicateHandlerMapping 使用 RouteLocator 获得 Route 信息。

### 2.5.1 Route

```org.springframework.cloud.gateway.route.Route``` ，路由。

```java

public class Route implements Ordered {
    /**
     * 路由编号
     */
    private final String id;
    /**
     * 路由向的 URI
     */
    private final URI uri;
    /**
     * 顺序
     */
    private final int order;
    /**
     * 谓语数组
     */
    private final Predicate<ServerWebExchange> predicate;
    /**
     * 过滤器数组
     */
    private final List<GatewayFilter> gatewayFilters;
}

```

* id 属性，ID 编号，唯一。
* predicates 属性，谓语数组。请求通过 predicates 判断是否匹配。
* filters 属性，过滤器数组。
* uri 属性，路由向的 URI 。
* order 属性，顺序。当请求匹配到多个路由时，使用顺序小的。

![image](http://spring-cloud-gateway-1252032169.cossh.myqcloud.com/predicates.png)\

* Route 内置 Builder 类，点击[链接](https://github.com/YunaiV/spring-cloud-gateway/blob/382a4cd98fbb8ac53a83a5559bacb0f885838074/spring-cloud-gateway-core/src/main/java/org/springframework/cloud/gateway/route/Route.java#L67)查看。
* Route 提供 routeDefinition RouteDefinition 创建对象
* predicate / gatewayFilters 属性，需要调用 Builder 相关方法进行设置。
```java

public static Builder builder(RouteDefinition routeDefinition) {
    return new Builder()
            .id(routeDefinition.getId())
            .uri(routeDefinition.getUri())
            .order(routeDefinition.getOrder());
}

```

### 2.5.2 RouteLocator

* ```org.springframework.cloud.gateway.route.RouteLocator``` ，路由定位器接口，定义获得路由数组的方法。

```java

public interface RouteLocator {
    Flux<Route> getRoutes();
}

```

![image](http://spring-cloud-gateway-1252032169.cossh.myqcloud.com/2-05.png)

* 本文只解析 CompositeRouteLocator / CachingRouteLocator 的源码实现。其他的实现类会在后面文章详细解析。
* 自定义的 RouteLocator ，通过内部类实现，类图暂时不好体现。

### 2.5.3 CompositeRouteLocator

```org.springframework.cloud.gateway.route.CompositeRouteLocator```，组合多种 RouteLocator 的实现类，为 RoutePredicateHandlerMapping 提供统一入口访问路由。

```java

public class CompositeRouteLocator implements RouteLocator {
    private final Flux<RouteLocator> delegates;
    public CompositeRouteLocator(Flux<RouteLocator> delegates) {
        this.delegates = delegates;
    }
    @Override
    public Flux<Route> getRoutes() {
        return this.delegates.flatMap(RouteLocator::getRoutes);
    }
}

```

* #getRoutes() 方法，提供统一方法，将组合的 delegates 的路由全部返回。

### 2.5.4 CachingRouteLocator

```org.springframework.cloud.gateway.route.CachingRouteLocator``` ，缓存路由的 RouteLocator 实现类。RoutePredicateHandlerMapping 调用 CachingRouteLocator 的 RouteLocator#getRoutes() 方法，获取路由。

```java

public class CachingRouteLocator implements RouteLocator {
    private final RouteLocator delegate;
    /**
     * 路由缓存
     */
    private final AtomicReference<List<Route>> cachedRoutes = new AtomicReference<>();
    public CachingRouteLocator(RouteLocator delegate) {
        this.delegate = delegate;
        this.cachedRoutes.compareAndSet(null, collectRoutes());
    }
    @Override
    public Flux<Route> getRoutes() {
        return Flux.fromIterable(this.cachedRoutes.get());
    }
    /**
     * Sets the new routes
     * @return old routes
     */
    public Flux<Route> refresh() {
        return Flux.fromIterable(this.cachedRoutes.getAndUpdate(
                routes -> CachingRouteLocator.this.collectRoutes()));
    }
    private List<Route> collectRoutes() {
        List<Route> routes = this.delegate.getRoutes().collectList().block();
        // 排序
        AnnotationAwareOrderComparator.sort(routes);
        return routes;
    }
    @EventListener(RefreshRoutesEvent.class)
    /* for testing */ void handleRefresh() {
        refresh();
    }
}

```

* GatewayWebfluxEndpoint 有一个 HTTP API 调用了 ApplicationEventPublisher ，发布 RefreshRoutesEvent 事件。

```java

@RestController
@RequestMapping("${management.context-path:/application}/gateway")
public class GatewayWebfluxEndpoint implements ApplicationEventPublisherAware {
    // ... 省略其他代码
    /**
    * 应用事件发布器
    */
    private ApplicationEventPublisher publisher;
    @PostMapping("/refresh")
    public Mono<Void> refresh() {
        this.publisher.publishEvent(new RefreshRoutesEvent(this));
        return Mono.empty();
    }
}

```

* ```POST "/refresh``` ，发布 RefreshRoutesEvent 事件。CachingRouteLocator 监听到该事件，刷新缓存。

## 2.6 RouteDefinitionRouteLocator 路由配置

![image](http://spring-cloud-gateway-1252032169.cossh.myqcloud.com/2-06.jpg)

### 2.6.1 RouteDefinitionRouteLocator

* ```org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator``` ，基于 RouteDefinitionLocator 的 RouteLocator 实现类。
* RouteDefinitionRouteLocator 从 RouteDefinitionLocator 获取 RouteDefinition ，转换成 Route 。

![image](http://spring-cloud-gateway-1252032169.cossh.myqcloud.com/2-07.jpg)

#### 2.6.1.1 构造方法

* RouteDefinitionRouteLocator 构造方法

```java

 1: public class RouteDefinitionRouteLocator implements RouteLocator, BeanFactoryAware {
 2:     protected final Log logger = LogFactory.getLog(getClass());
 3:
 4:     private final RouteDefinitionLocator routeDefinitionLocator;
 5:     /**
 6:      * RoutePredicateFactory 映射
 7:      * key ：{@link RoutePredicateFactory#name()}
 8:      */
 9:     private final Map<String, RoutePredicateFactory> predicates = new LinkedHashMap<>();
10:     /**
11:      * GatewayFilterFactory 映射
12:      * key ：{@link GatewayFilterFactory#name()}
13:      */
14:     private final Map<String, GatewayFilterFactory> gatewayFilterFactories = new HashMap<>();
15:     private final GatewayProperties gatewayProperties;
16:     private final SpelExpressionParser parser = new SpelExpressionParser();
17:     private BeanFactory beanFactory;
18:
19:     public RouteDefinitionRouteLocator(RouteDefinitionLocator routeDefinitionLocator,
20:                                        List<RoutePredicateFactory> predicates,
21:                                        List<GatewayFilterFactory> gatewayFilterFactories,
22:                                        GatewayProperties gatewayProperties) {
23:         // 设置 RouteDefinitionLocator
24:         this.routeDefinitionLocator = routeDefinitionLocator;
25:         // 初始化 RoutePredicateFactory
26:         initFactories(predicates);
27:         // 初始化 RoutePredicateFactory
28:         gatewayFilterFactories.forEach(factory -> this.gatewayFilterFactories.put(factory.name(), factory));
29:         // 设置 GatewayProperties
30:         this.gatewayProperties = gatewayProperties;
31:     }
32:
33:     @Override
34:     public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
35:         this.beanFactory = beanFactory;
36:     }
37:}

```

* routeDefinitionLocator 属性，提供 RouteDefinition 的 RouteDefinitionLocator 。
* predicates 属性，RoutePredicateFactory Bean 对象映射。
  * key 为 {@link RoutePredicateFactory#name()} 。
  * 通过它，将 RouteDefinition.predicates 转换成 Route.predicates 。
  * 第 26 行 ：调用 #initFactories() 方法，初始化映射。逻辑比较简单，点击 链接 查看代码。
* gatewayFilterFactories 属性，RoutePredicateFactory Bean 对象映射。
  * key 为 {@link GatewayFilterFactory#name()} 。
  * 通过它，将 RouteDefinition.filters 转换成 Route.filters 。
  * 第 28 行 ：初始化映射。
* gatewayProperties 属性，使用 GatewayProperties.defaultFilters 默认过滤器定义数组，添加到每个 Route 。下文会看到相关代码的实现。
* parser 属性，Spring EL 表达式解析器。在 「2.4 获得 Tuple」 会看到它的使用。
* beanFactory 属性，Bean 工厂。