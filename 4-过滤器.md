# 4. 过滤器

## 4.1 GatewayFilter一览

### 4.1.1 概述

* 过滤器整体类图如下 ：

![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_01/01.png)

### 4.1.2 GatewyFilter

```org.springframework.cloud.gateway.filter.GatewayFilter``` ，网关过滤器接口，代码如下 ：

```java

public interface GatewayFilter {
    /**
     * Process the Web request and (optionally) delegate to the next
     * {@code WebFilter} through the given {@link GatewayFilterChain}.
     * @param exchange the current server exchange
     * @param chain provides a way to delegate to the next filter
     * @return {@code Mono<Void>} to indicate when request processing is complete
     */
    Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);
}

```

* 从接口方法可以看到，和 javax.servlet.Filter 类似。

* GatewayFilter 有三种类型的子类实现，我们下面每节介绍一种。

#### 4.1.2.1 GatewayFilterFactory 内部类

* 在每个 GatewayFilterFactory 实现类的 ```#apply(Tuple)``` 方法里，都声明了一个实现 GatewayFilter 的内部类，以 ```AddRequestHeaderGatewayFilterFactory``` 的代码举例子 ：

```java

 1: public class AddRequestHeaderGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     @Override
 4:     public List<String> argNames() {
 5:         return Arrays.asList(NAME_KEY, VALUE_KEY);
 6:     }
 7:
 8:     @Override
 9:     public GatewayFilter apply(Tuple args) {
10:         String name = args.getString(NAME_KEY);
11:         String value = args.getString(VALUE_KEY);
12:
13:         return (exchange, chain) -> { // GatewayFilter
14:             ServerHttpRequest request = exchange.getRequest().mutate()
15:                     .header(name, value)
16:                     .build();
17:
18:             return chain.filter(exchange.mutate().request(request).build());
19:         };
20:     }
21: }

```

* 第 13 至 19 行 ：定义了一个 GatewayFilter 内部实现类。

#### 4.1.2.2 OrderedGatewayFilter

```org.springframework.cloud.gateway.filter.OrderedGatewayFilter``` ，有序的网关过滤器实现类。在 FilterChain 里，过滤器数组首先会按照 order 升序排序，按照顺序过滤请求。代码如下 ：

```java

public class OrderedGatewayFilter implements GatewayFilter, Ordered {
    private final GatewayFilter delegate;
    private final int order;
    public OrderedGatewayFilter(GatewayFilter delegate, int order) {
        this.delegate = delegate;
        this.order = order;
    }
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return this.delegate.filter(exchange, chain);
    }
    @Override
    public int getOrder() {
        return this.order;
    }
}

```

* ```delegate``` 属性，委托的 GatewayFilter 。
* ```order``` 属性，顺序。
* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，使用 delegate 过滤请求。

#### 4.1.2.3 GatewayFilterAdapter

```org.springframework.cloud.gateway.handler.FilteringWebHandler.GatewayFilterAdapter``` ，网关过滤器适配器。在 GatewayFilterChain 使用 GatewayFilter 过滤请求，所以通过 GatewayFilterAdapter 将 GlobalFilter 适配成 GatewayFilter 。GatewayFilterAdapter 代码如下 ：

```java

private static class GatewayFilterAdapter implements GatewayFilter {
    private final GlobalFilter delegate;

    public GatewayFilterAdapter(GlobalFilter delegate) {
        this.delegate = delegate;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return this.delegate.filter(exchange, chain);
    }
}

```

* ```delegate``` 属性，委托的 GlobalFilter 。
* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，使用 delegate 过滤请求。
* 在 FilteringWebHandler 初始化时，将 GlobalFilter 委托成 GatewayFilterAdapter ，代码如下 ：

```java

 1: public class FilteringWebHandler implements WebHandler {
 2:
 3:     /**
 4:      * 全局过滤器
 5:      */
 6:     private final List<GatewayFilter> globalFilters;
 7:
 8:     public FilteringWebHandler(List<GlobalFilter> globalFilters) {
 9:         this.globalFilters = loadFilters(globalFilters);
10:     }
11:
12:     private static List<GatewayFilter> loadFilters(List<GlobalFilter> filters) {
13:         return filters.stream()
14:                 .map(filter -> {
15:                     GatewayFilterAdapter gatewayFilter = new GatewayFilterAdapter(filter);
16:                     if (filter instanceof Ordered) {
17:                         int order = ((Ordered) filter).getOrder();
18:                         return new OrderedGatewayFilter(gatewayFilter, order);
19:                     }
20:                     return gatewayFilter;
21:                 }).collect(Collectors.toList());
22:     }
23: }

```

* 第 16 至 19 行 ：当 GlobalFilter 子类实现了 ```org.springframework.core.Ordered``` 接口，在委托一层 OrderedGatewayFilter 。这样 ```AnnotationAwareOrderComparator#sort(List)``` 方法好排序。
* 第 20 行 ：当 GlobalFilter 子类没有实现了 ```org.springframework.core.Ordered``` 接口，在 ```AnnotationAwareOrderComparator#sort(List)``` 排序时，顺序值为 ```Integer.MAX_VALUE``` 。
* 目前 GlobalFilter 都实现了 ```org.springframework.core.Ordered``` 接口。

### 4.1.3 GlobalFilter

* ```org.springframework.cloud.gateway.filter.GlobalFilter``` ，全局过滤器接口，代码如下 ：

```java

public interface GlobalFilter {
    /**
     * Process the Web request and (optionally) delegate to the next
     * {@code WebFilter} through the given {@link GatewayFilterChain}.
     * @param exchange the current server exchange
     * @param chain provides a way to delegate to the next filter
     * @return {@code Mono<Void>} to indicate when request processing is complete
     */
    Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);
}

```

* GlobalFilter 和 GatewayFilter 的 ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法签名一致。官方说，未来的版本将作出一些调整。
* GlobalFilter 会作用到所有的 Route 上。
* GlobalFilter 实现类如下类图 ：
![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_01/02.png)
* RoutingFilter
  * NettyRoutingFilter
  * WebClientHttpRoutingFilter
  * WebsocketRoutingFilter
  * ForwardRoutingFilter
* 成对的 Filter
  * NettyRoutingFilter / NettyWriteResponseFilter
  * WebClientHttpRoutingFilter / WebClientWriteResponseFilter


### 4.1.4 GatewayFilterChain

```org.springframework.cloud.gateway.filter.GatewayFilterChain``` ，网关过滤器链接口。代码如下 ：

```java

public interface GatewayFilterChain {
    /**
     * Delegate to the next {@code WebFilter} in the chain.
     * @param exchange the current server exchange
     * @return {@code Mono<Void>} to indicate when request handling is complete
     */
    Mono<Void> filter(ServerWebExchange exchange);
}

```

* 从接口方法可以看到，和 javax.servlet.FilterChain 类似。

* ```org.springframework.cloud.gateway.handler.FilteringWebHandler.GatewayFilterAdapter``` ，网关过滤器链默认实现类。代码如下 ：

```java

private static class DefaultGatewayFilterChain implements GatewayFilterChain {
    private int index;
    private final List<GatewayFilter> filters;
    public DefaultGatewayFilterChain(List<GatewayFilter> filters) {
        this.filters = filters;
    }
    @Override
    public Mono<Void> filter(ServerWebExchange exchange) {
        if (this.index < filters.size()) {
            GatewayFilter filter = filters.get(this.index++);
            return filter.filter(exchange, this);
        } else {
            return Mono.empty(); // complete
        }
    }
}

```

## 4.2 GatewayFilterFactory 过滤器工厂

### 4.2.1 概述

![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_05/01.png)

### 4.2.2 Header

>Header 相关的 GatewayFilterFactory 实现类。

#### 4.2.2.1 AddRequestHeaderGatewayFilterFactory

* 用途 ：添加指定请求 Header 为指定值。
* 配置 ：

```yaml

spring:
  cloud:
    gateway:
      routes:
      # =====================================
      - id: add_request_header_route
        uri: http://example.org
        filters:
        - AddRequestHeader=X-Request-Foo, Bar

```

* 代码

```java

 1: public class AddRequestHeaderGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     @Override
 4:     public List<String> argNames() {
 5:         return Arrays.asList(NAME_KEY, VALUE_KEY);
 6:     }
 7:
 8:     @Override
 9:     public GatewayFilter apply(Tuple args) {
10:         String name = args.getString(NAME_KEY);
11:         String value = args.getString(VALUE_KEY);
12:
13:         return (exchange, chain) -> { // GatewayFilter
14:             // 创建新的 ServerHttpRequest
15:             ServerHttpRequest request = exchange.getRequest().mutate()
16:                     .header(name, value)
17:                     .build();
18:
19:             // 创建新的 ServerWebExchange ，提交过滤器链继续过滤
20:             return chain.filter(exchange.mutate().request(request).build());
21:         };
22:     }
23: }

```

* Tuple 参数 ：name / value 。
* 第 14 至 17 行 ：创建新的 ServerHttpRequest 。
* 第 19 至 20 行 ：创建新的 ServerWebExchange ，提交过滤器链继续过滤。

#### 4.2.2.2 RemoveRequestHeaderGatewayFilterFactory

* 类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— RemoveRequestHeader GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#removerequestheader-gatewayfilter-factory) 查看官方文档。

#### 4.2.2.3 AddResponseHeaderGatewayFilterFactory

* 类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— AddResponseHeader GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#addresponseheader-gatewayfilter-factory) 查看官方文档。

#### 4.2.2.4 RemoveResponseHeaderGatewayFilterFactory

类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— RemoveResponseHeader GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#removeresponseheader-gatewayfilter-factory) 查看官方文档。

#### 4.2.2.5 SetResponseHeaderGatewayFilterFactory

类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— SetStatus GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#removeresponseheader-gatewayfilter-factory)  查看官方文档。

#### 4.2.2.6 RemoveNonProxyHeadersGatewayFilterFactory

* 用途 ：移除请求 **Proxy** 相关的 Header 。默认值为 ```[ "Connection", "Keep-Alive", "Proxy-Authenticate", "Proxy-Authorization", "TE", "Trailer", "Transfer-Encoding", "Upgrade" ] ( 参考自 ：https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-14#section-7.1.3 )``` ，可以通过 ```spring.cloud.gateway.filter.remove-non-proxy-headers``` 配置。
* 代码 ：

```java

1: @ConfigurationProperties("spring.cloud.gateway.filter.remove-non-proxy-headers")
 2: public class RemoveNonProxyHeadersGatewayFilterFactory implements GatewayFilterFactory {
 3:
 4:     /**
 5:      * 默认
 6:      */
 7:     public static final String[] DEFAULT_HEADERS_TO_REMOVE = new String[] {"Connection", "Keep-Alive",
 8:             "Proxy-Authenticate", "Proxy-Authorization", "TE", "Trailer", "Transfer-Encoding", "Upgrade"};
 9:
10:     private List<String> headers = Arrays.asList(DEFAULT_HEADERS_TO_REMOVE);
11:
12:     public List<String> getHeaders() {
13:         return headers;
14:     }
15:
16:    public void setHeaders(List<String> headers) {
17:         this.headers = headers;
18:     }
19:
20:     @Override
21:     public GatewayFilter apply(Tuple args) {
22:         //TODO: support filter args
23:
24:         return (exchange, chain) -> {
25:             // 创建新的 ServerHttpRequest
26:             ServerHttpRequest request = exchange.getRequest().mutate()
27:                     .headers(httpHeaders -> {
28:                         for (String header : this.headers) {
29:                             httpHeaders.remove(header); // 移除
30:                         }
31:                     })
32:                     .build();
33:
34:             // 创建新的 ServerWebExchange ，提交过滤器链继续过滤
35:             return chain.filter(exchange.mutate().request(request).build());
36:         };
37:     }
38:

```

#### 4.2.2.7 SecureHeadersGatewayFilterFactory

* 用途 ：添加响应 Secure 相关的 Header 。默认值在 ```org.springframework.cloud.gateway.filter.factory.SecureHeadersProperties``` ，可以通过 ```spring.cloud.gateway.filter.secure-headers``` 配置。
* 代码 ：

```java

 1: public class SecureHeadersGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     public static final String X_XSS_PROTECTION_HEADER = "X-Xss-Protection";
 4:     public static final String STRICT_TRANSPORT_SECURITY_HEADER = "Strict-Transport-Security";
 5:     public static final String X_FRAME_OPTIONS_HEADER = "X-Frame-Options";
 6:     public static final String X_CONTENT_TYPE_OPTIONS_HEADER = "X-Content-Type-Options";
 7:     public static final String REFERRER_POLICY_HEADER = "Referrer-Policy";
 8:     public static final String CONTENT_SECURITY_POLICY_HEADER = "Content-Security-Policy";
 9:     public static final String X_DOWNLOAD_OPTIONS_HEADER = "X-Download-Options";
10:     public static final String X_PERMITTED_CROSS_DOMAIN_POLICIES_HEADER = "X-Permitted-Cross-Domain-Policies";
11:
12:     private final SecureHeadersProperties properties;
13:
14:     public SecureHeadersGatewayFilterFactory(SecureHeadersProperties properties) {
15:         this.properties = properties;
16:     }
17:
18:     @Override
19:     public GatewayFilter apply(Tuple args) {
20:         //TODO: allow args to override properties
21:
22:         return (exchange, chain) -> {
23:             HttpHeaders headers = exchange.getResponse().getHeaders();
24:
25:             //TODO: allow header to be disabled
26:             headers.add(X_XSS_PROTECTION_HEADER, properties.getXssProtectionHeader());
27:             headers.add(STRICT_TRANSPORT_SECURITY_HEADER, properties.getStrictTransportSecurity());
28:             headers.add(X_FRAME_OPTIONS_HEADER, properties.getFrameOptions());
29:             headers.add(X_CONTENT_TYPE_OPTIONS_HEADER, properties.getContentTypeOptions());
30:             headers.add(REFERRER_POLICY_HEADER, properties.getReferrerPolicy());
31:             headers.add(CONTENT_SECURITY_POLICY_HEADER, properties.getContentSecurityPolicy());
32:             headers.add(X_DOWNLOAD_OPTIONS_HEADER, properties.getDownloadOptions());
33:             headers.add(X_PERMITTED_CROSS_DOMAIN_POLICIES_HEADER, properties.getPermittedCrossDomainPolicies());
34:
35:             return chain.filter(exchange);
36:         };
37:     }
38: }

```

*　第 26 至 33 行 ：添加响应 Secure 相关的 Header 。

### 4.2.3 Parameter

> Parameter 相关的 GatewayFilterFactory 实现类。

#### 4.2.3.1 AddRequestParameterGatewayFilterFactory

类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— AddRequestParameter GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#addrequestheader-gatewayfilter-factory) 查看官方文档。

### 4.2.4 Path

>Path 相关的 GatewayFilterFactory 实现类。

#### 4.2.4.1 RewritePathGatewayFilterFactory

* 用途 ：根据配置的正则表达式 regexp ，使用配置的 replacement 重写请求 Path 。从功能目的上类似 《Module ngx_http_rewrite_module》 。
* 配置 ：

```yaml

spring:
  cloud:
    gateway:
      routes:
      # =====================================
      - id: rewritepath_route
        uri: http://example.org
        predicates:
        - Path=/foo/**
        filters:
        - RewritePath=/foo/(?<segment>.*), /$\{segment}

```

* 注意，$\ 用于替代 $ ，避免和 YAML 语法冲突。

```java

 1: public class RewritePathGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     public static final String REGEXP_KEY = "regexp";
 4:     public static final String REPLACEMENT_KEY = "replacement";
 5:
 6:     @Override
 7:     public List<String> argNames() {
 8:         return Arrays.asList(REGEXP_KEY, REPLACEMENT_KEY);
 9:     }
10:
11:     @Override
12:     public GatewayFilter apply(Tuple args) {
13:         final String regex = args.getString(REGEXP_KEY);
14:         // `$\` 用于替代 `$` ，避免和 YAML 语法冲突。
15:         String replacement = args.getString(REPLACEMENT_KEY).replace("$\\", "$");
16:
17:         return (exchange, chain) -> {
18:             ServerHttpRequest req = exchange.getRequest();
19:             // 添加 原始请求URI 到 GATEWAY_ORIGINAL_REQUEST_URL_ATTR
20:             addOriginalRequestUrl(exchange, req.getURI());
21:             // 重写 Path
22:             String path = req.getURI().getPath();
23:             String newPath = path.replaceAll(regex, replacement);
24:
25:             // 创建新的 ServerHttpRequest
26:             ServerHttpRequest request = req.mutate()
27:                     .path(newPath) // 设置 Path
28:                     .build();
29:
30:             // 添加 请求URI 到 GATEWAY_REQUEST_URL_ATTR
31:             exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, request.getURI());
32:
33:             // 创建新的 ServerWebExchange ，提交过滤器链继续过滤
34:             return chain.filter(exchange.mutate().request(request).build());
35:         };
36:     }
37: }

```

* Tuple 参数 ：regexp / replacement 。
* 第 15 行 ：$\ 用于替代 $ ，避免和 YAML 语法冲突。
* 第 20 行 ：调用 ```ServerWebExchangeUtils#addOriginalRequestUrl(...)``` 添加原始请求 URI 到 ```GATEWAY_ORIGINAL_REQUEST_URL_ATTR``` 。代码如下 ：

```java

public static void addOriginalRequestUrl(ServerWebExchange exchange, URI url) {
        exchange.getAttributes().computeIfAbsent(GATEWAY_ORIGINAL_REQUEST_URL_ATTR, s -> new LinkedHashSet<>()); // 数组，考虑多次重写
    LinkedHashSet<URI> uris = exchange.getRequiredAttribute(GATEWAY_ORIGINAL_REQUEST_URL_ATTR);
    uris.add(url);
}

```

* 为什么使用 LinkedHashSet ？因为可以使用 RewritePathGatewayFilterFactory / PrefixPathGatewayFilterFactory 多次重写。

* 第 21 至 23 行 ：重写请求 Path 。
* 第 26 至 28 行 ：创建新的 ServerHttpRequest 。
* 第 31 行 ：添加请求 URI 到 GATEWAY_REQUEST_URL_ATTR 。
* 第 34 行 ：创建新的 ServerWebExchange ，提交过滤器链继续过滤。

#### 4.2.4.2 PrefixPathGatewayFilterFactory

类似 RewritePathGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— PrefixPath GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#setpath-gatewayfilter-factory) 查看官方文档。

#### 4.2.4.3 SetPathGatewayFilterFactory

类似 RewritePathGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— SetPath GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#prefixpath-gatewayfilter-factory) 查看官方文档。

### 4.2.5 Status

>Status 相关的 GatewayFilterFactory 实现类。

#### 4.2.5.1 SetStatusGatewayFilterFactory

类似 RedirectToGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— SetStatus GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#setstatus-gatewayfilter-factory) 查看官方文档。

### 4.2.6 Redirect

>Redirect 相关的 GatewayFilterFactory 实现类。

#### 4.2.6.1 RedirectToGatewayFilterFactory

用途 ：将响应重定向到指定 URL ，并设置响应状态码为指定 Status 。注意，Status 必须为 3XX 重定向状态码。
配置 ：

```yaml

spring:
  cloud:
    gateway:
      routes:
      # =====================================
      - id: prefixpath_route
        uri: http://example.org
        filters:
        - RedirectTo=302, http://www.iocoder.cn

```

代码 ：

```java

 1: public class RedirectToGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     public static final String STATUS_KEY = "status";
 4:     public static final String URL_KEY = "url";
 5:
 6:     @Override
 7:     public List<String> argNames() {
 8:         return Arrays.asList(STATUS_KEY, URL_KEY);
 9:     }
10:
11:     @Override
12:     public GatewayFilter apply(Tuple args) {
13:         String statusString = args.getRawString(STATUS_KEY);
14:         String urlString = args.getString(URL_KEY);
15:
16:         // 解析 status ，并判断是否是 3XX 重定向状态
17:         final HttpStatus httpStatus = parse(statusString);
18:         Assert.isTrue(httpStatus.is3xxRedirection(), "status must be a 3xx code, but was " + statusString);
19:         // 创建 URL
20:         final URL url;
21:         try {
22:             url = URI.create(urlString).toURL();
23:         } catch (MalformedURLException e) {
24:             throw new IllegalArgumentException("Invalid url " + urlString, e);
25:         }
26:
27:         return (exchange, chain) ->
28:             chain.filter(exchange).then(Mono.defer(() -> { // After Filter
29:                 if (!exchange.getResponse().isCommitted()) {
30:                     // 设置响应 Status
31:                     setResponseStatus(exchange, httpStatus);
32:
33:                     // 设置响应 Header
34:                     final ServerHttpResponse response = exchange.getResponse();
35:                     response.getHeaders().set(HttpHeaders.LOCATION, url.toString());
36:                     return response.setComplete();
37:                 }
38:                 return Mono.empty();
39:             }));
40:     }
41:
42: }

```

* 第 16 至 18 行 ：解析配置的 statusString ，并判断是否是 3XX 重定向状态码。
* 第 19 至 25 行 ：解析配置的 urlString ，创建 URL 。
* 第 28 行 ：调用 ```#then(Mono)``` 方法，实现 After Filter 逻辑。这里和 AddRequestHeaderGatewayFilterFactory 实现的 Before Filter 【方式】不同。
* 第 29 至 37 行 ：若响应未提交，设置响应的状态码、响应的 Header ( Location ) 。
* 第 38 行 ：设置响应已提交。

## 4.3 RouteToRequestUrlFilter

### 4.3.1 概述

>本文主要分享 RouteToRequestUrlFilter 的代码实现。

* RouteToRequestUrlFilter 根据匹配的 Route ，计算请求的地址。注意，**这里的地址指的是 URL ，而不是 URI 。**

### 4.3.2 RouteToRequestUrlFilter

```org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter``` ，代码如下 ：

```java

 1: public class RouteToRequestUrlFilter implements GlobalFilter, Ordered {
 2:
 3:     private static final Log log = LogFactory.getLog(RouteToRequestUrlFilter.class);
 4:     public static final int ROUTE_TO_URL_FILTER_ORDER = 10000;
 5:
 6:     @Override
 7:     public int getOrder() {
 8:         return ROUTE_TO_URL_FILTER_ORDER;
 9:     }
10:
11:     @Override
12:     public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
13:         // 获得 Route
14:         Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);
15:         if (route == null) {
16:             return chain.filter(exchange);
17:         }
18:         log.trace("RouteToRequestUrlFilter start");
19:         // 拼接 requestUrl
20:         URI requestUrl = UriComponentsBuilder.fromHttpRequest(exchange.getRequest())
21:                 .uri(route.getUri())
22:                 .build(true) // encoded=true
23:                 .toUri();
24:         // 设置 requestUrl 到 GATEWAY_REQUEST_URL_ATTR {@link RewritePathGatewayFilterFactory}
25:         exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, requestUrl);
26:         // 提交过滤器链继续过滤
27:         return chain.filter(exchange);
28:     }
29:
30: }

```

* 实现 GlobalFilter 接口。
* ```#getOrder()``` 方法，返回顺序为 10000 。在GlobalFilter ，我们列举了所有 GlobalFilter 的顺序。
* 第 13 至 18 行 ：获得请求匹配的 Route ，在RoutePredicateHandlerMapping 路由匹配有详细解析。
* 第 20 至 23 行 ：拼接 requestUrl 。这里有一点要注意下，如果 Route.uri 属性配置带有 Path ，则会覆盖请求的 Path 。

```yaml

Route.uri    Request.uri    requestUrl
http://bin.org:80    http://127.0.0.1:8080/test/segment    http://httpbin.org:80/123
http://bin.org:80/123    http://127.0.0.1:8080/test/segment    http://httpbin.org:80/test/segment

```

* 为什么会导致覆盖的情况呢 ？答案在 UriComponentsBuilder#uri(URI) 方法，代码如下 ：

```java

 1: public UriComponentsBuilder uri(URI uri) {
 2:     Assert.notNull(uri, "URI must not be null");
 3:     this.scheme = uri.getScheme();
 4:     if (uri.isOpaque()) {
 5:         this.ssp = uri.getRawSchemeSpecificPart();
 6:         resetHierarchicalComponents();
 7:     }
 8:     else {
 9:         if (uri.getRawUserInfo() != null) {
10:             this.userInfo = uri.getRawUserInfo();
11:         }
12:         if (uri.getHost() != null) {
13:             this.host = uri.getHost();
14:         }
15:         if (uri.getPort() != -1) {
16:             this.port = String.valueOf(uri.getPort());
17:         }
18:         if (StringUtils.hasLength(uri.getRawPath())) {
19:             this.pathBuilder = new CompositePathComponentBuilder();
20:             this.pathBuilder.addPath(uri.getRawPath());
21:         }
22:         if (StringUtils.hasLength(uri.getRawQuery())) {
23:             this.queryParams.clear();
24:             query(uri.getRawQuery());
25:         }
26:         resetSchemeSpecificPart();
27:     }
28:     if (uri.getRawFragment() != null) {
29:         this.fragment = uri.getRawFragment();
30:     }
31:     return this;
32: }

```
* 第 18 至 21 行 ：当 uri 参数有 Path 时，新建一个 CompositePathComponentBuilder ，因此原有的 this.pathBuilder 被覆盖了。
* 第 25 行 ：设置 requestUrl 到 GATEWAY_REQUEST_URL_ATTR 。后面 Routing 相关的 GatewayFilter 会通过该属性，发起请求。
* 第 27 行 ：提交过滤器链继续过滤。注意，这里不需要创建新的 ServerWebExchange

## 4.4 LoadBalancerClientFilter

### 4.4.1 概述

>LoadBalancerClientFilter 的代码实现。**LoadBalancerClientFilter 根据 lb:// 前缀过滤处理，使用 serviceId 选择一个服务实例，从而实现负载均衡。**

### 4.4.2 环境搭建

* 请见 (2-路由.md) 2.4.2 环境搭建

### 4.4.3 LoadBalancerClientFilter

* ```org.springframework.cloud.gateway.filter.LoadBalancerClientFilter``` ，代码如下 ：

```java

 1: public class LoadBalancerClientFilter implements GlobalFilter, Ordered {
 2:
 3:     private static final Log log = LogFactory.getLog(LoadBalancerClientFilter.class);
 4:     public static final int LOAD_BALANCER_CLIENT_FILTER_ORDER = 10100;
 5:
 6:     private final LoadBalancerClient loadBalancer;
 7:
 8:     public LoadBalancerClientFilter(LoadBalancerClient loadBalancer) {
 9:         this.loadBalancer = loadBalancer;
10:     }
11:
12:     @Override
13:     public int getOrder() {
14:         return LOAD_BALANCER_CLIENT_FILTER_ORDER;
15:     }
16:
17:     @Override
18:     public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
19:         // 获得 URL
20:         URI url = exchange.getAttribute(GATEWAY_REQUEST_URL_ATTR);
21:         if (url == null || !url.getScheme().equals("lb")) {
22:             return chain.filter(exchange);
23:         }
24:         // 添加 原始请求URI 到 GATEWAY_ORIGINAL_REQUEST_URL_ATTR
25:         //preserve the original url
26:         addOriginalRequestUrl(exchange, url);
27:
28:         log.trace("LoadBalancerClientFilter url before: " + url);
29:
30:         // 获取 服务实例
31:         final ServiceInstance instance = loadBalancer.choose(url.getHost());
32:         if (instance == null) {
33:             throw new NotFoundException("Unable to find instance for " + url.getHost());
34:         }
35:
36:         /*URI uri = exchange.getRequest().getURI();
37:         URI requestUrl = loadBalancer.reconstructURI(instance, uri);*/
38:         //
39:         URI requestUrl = UriComponentsBuilder.fromUri(url)
40:                 .scheme(instance.isSecure()? "https" : "http") //TODO: support websockets
41:                 .host(instance.getHost())
42:                 .port(instance.getPort())
43:                 .build(true)
44:                 .toUri();
45:         log.trace("LoadBalancerClientFilter url chosen: " + requestUrl);
46:
47:         // 添加 请求URI 到 GATEWAY_REQUEST_URL_ATTR
48:         exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, requestUrl);
49:
50:         // 提交过滤器链继续过滤
51:         return chain.filter(exchange);
52:     }
53:
54: }

```

* 第 19 至 23 行 ：获得 URL 。只处理 lb:// 为前缀( Scheme )的地址。
* 第 第 26 行 ：调用 ```ServerWebExchangeUtils#addOriginalRequestUrl(...)``` 添加原始请求 URI 到 GATEWAY_ORIGINAL_REQUEST_URL_ATTR 。代码如下 ：

```java

public static void addOriginalRequestUrl(ServerWebExchange exchange, URI url) {
        exchange.getAttributes().computeIfAbsent(GATEWAY_ORIGINAL_REQUEST_URL_ATTR, s -> new LinkedHashSet<>()); // 数组，考虑多次重写
    LinkedHashSet<URI> uris = exchange.getRequiredAttribute(GATEWAY_ORIGINAL_REQUEST_URL_ATTR);
    uris.add(url);
}

```

* 为什么使用 LinkedHashSet ？因为可以使用 RewritePathGatewayFilterFactory / PrefixPathGatewayFilterFactory 多次重写。
* 第 30 至 34 行 ：调用 ```LoadBalancerClient#choose(String)``` 方法，获得一个服务实例( ServiceInstance ) ，从而实现负载均衡。
* 熟悉 Spring Cloud 的同学都知道，一般情况下 LoadBalancerClient 实现类为 ``org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient`` 。
* 举个 instance 的值例子 ：
![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_15/01.png)
* 第 39 至 45 行 ：创建 requestUrl 。举个例子 ：
![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_15/02.png)
* 第 48 行 ：设置 requestUrl 到 GATEWAY_REQUEST_URL_ATTR 。后面 Routing 相关的 GatewayFilter 会通过该属性，发起请求。
* 第 51 行 ：提交过滤器链继续过滤。注意，这里不需要创建新的 ServerWebExchange

### 4.5 ForwardRoutingFilter

### 4.5.1 概述

>分享 ForwardRoutingFilter 的代码实现。

* RouteToRequestUrlFilter ，转发路由网关过滤器。其根据 forward:// 前缀( Scheme )过滤处理，将请求转发到当前网关实例本地接口。
* 举个例子，配置 RouteDefinition 路由定义如下 ：

```yaml

spring:
  application:
      name: juejin-gateway
  cloud:
    gateway:
      routes:
      # =====================================
      - id: forward_sample
        uri: forward:///globalfilters
        order: 10000
        predicates:
        - Path=/globalfilters
        filters:
        - PrefixPath=/application/gateway

```

* 我们假定网关端口为 8080 。
* 当请求 <http://127.0.0.1:8080/globalfilters> 接口，Spring Cloud Gateway 处理过程如下 ：
  * 匹配到路由 Route (id = forward_sample) 。
  * 配置的 PrefixPathGatewayFilterFactory 将请求改写成 <http://127.0.0.1:8080/application/gateway/globalfilters> 。
  * ForwardRoutingFilter 判断有 forward:// 前缀( Scheme )，过滤处理，将请求转发给 DispatcherHandler 。
  * DispatcherHandler 匹配并转发到当前网关实例本地接口 application/gateway/globalfilters 。
* 为什么需要配置 PrefixPathGatewayFilterFactory ？需要通过 PrefixPathGatewayFilterFactory 将请求重写路径，以匹配本地 API ，否则 DispatcherHandler 转发会失败。
* 另外，RouteToRequestUrlFilter 是 Spring Cloud Gateway 实现的一种路由网关过滤器，目前还提供 WebsocketRoutingFilter / NettyRoutingFilter / WebClientHttpRoutingFilter 。

### 4.5.2 RouteToRequestUrlFilter

* ```org.springframework.cloud.gateway.filter.ForwardRoutingFilter``` ，代码如下 ：

```java

 1: public class ForwardRoutingFilter implements GlobalFilter, Ordered {
 2:
 3:     private static final Log log = LogFactory.getLog(ForwardRoutingFilter.class);
 4:
 5:     private final DispatcherHandler dispatcherHandler;
 6:
 7:     public ForwardRoutingFilter(DispatcherHandler dispatcherHandler) {
 8:         this.dispatcherHandler = dispatcherHandler;
 9:     }
10:
11:     @Override
12:     public int getOrder() {
13:         return Ordered.LOWEST_PRECEDENCE;
14:     }
15:
16:     @Override
17:     public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
18:         // 获得 requestUrl
19:         URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);
20:
21:         // 判断是否能够处理
22:         String scheme = requestUrl.getScheme();
23:         if (isAlreadyRouted(exchange) || !scheme.equals("forward")) {
24:             return chain.filter(exchange);
25:         }
26:
27:         // 设置已经路由
28:         setAlreadyRouted(exchange);
29:
30:         //TODO: translate url?
31:
32:         if (log.isTraceEnabled()) {
33:             log.trace("Forwarding to URI: "+requestUrl);
34:         }
35:
36:         // DispatcherHandler 匹配并转发到当前网关实例本地接口
37:         return this.dispatcherHandler.handle(exchange);
38:     }
39: }

```

* 实现 GlobalFilter 接口。
* ```#getOrder()``` 方法，返回顺序为 ```Integer.MAX_VALUE``` 。在 《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」 ，我们列举了所有 GlobalFilter 的顺序。
* 第 19 行 ：获得 ```requestUrl``` 。
* 第 22 至 25 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：
* ```forward://``` 前缀( Scheme ) 。
* 调用 ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange) 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：

```java

public static boolean isAlreadyRouted(ServerWebExchange exchange) {
    return exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, false);
}

```

* 第 28 行 ：设置该请求已经被处理。代码如下 ：

```java

public static void setAlreadyRouted(ServerWebExchange exchange) {
    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, true);
}

```

* 第 37 行 ：将请求转发给 DispatcherHandler 。DispatcherHandler 匹配并转发到当前网关实例本地接口。

## 4.6 WebSocketRoutingFilter

### 4.6.1 概述

>主要分享 WebsocketRoutingFilter 的代码实现。

* WebsocketRoutingFilter ，Websocket 路由网关过滤器。其根据 ```ws:// / wss:// 前缀( Scheme )```过滤处理，代理后端 Websocket 服务，提供给客户端连接。如下图 ：

![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_25/01.png)

* 目前一个 RouteDefinition 只能指定一个后端 WebSocket 服务。官方正在计划在 LoadBalancerClientFilter 上实现 Websocket 的负载均衡功能。也就说，未来一个 RouteDefinition 能够指定多个后端 WebSocket 服务。

* Websocket 的 RouteDefinition 配置如下 ：

```yaml

cloud:
    gateway:
      routes:
      - id: websocket_test
        uri: ws://localhost:9000
        order: 8000
        predicates:
        - Path=/echo

```

* uri 使用 ws:// 或者 wss:// 为前缀。

### 4.6.2 环境搭建

>在解析源码之前，我们先以 wscat 搭建一个 WebSocket 服务。

* 第一步，安装 wscat 。

```javascript

npm install -g wscat

```

* 第二步，启动 wscat 。

```javascript

wscat --listen 9000

```

* 第三步，连接 wscat 。

```javascript

wscat --listen 9000

```

* 第四步，配置 RouteDefinition ，并启动 Spring Cloud Gateway 。

```yaml

cloud:
    gateway:
      routes:
      - id: websocket_test
        uri: ws://localhost:9000
        order: 8000
        predicates:
        - Path=/echo

```

* 第五步，通过 Gateway 连接 wscat 。

```javascript

wscat --connect ws://localhost:8080/echo

```
大功告成。

>注意，wscat 同一时间仅允许一个客户端连接。

### 4.6.3 WebsocketRoutingFilter

* ```org.springframework.cloud.gateway.filter.WebsocketRoutingFilter``` ，Websocket 路由网关过滤器。

* 构造方法，代码如下 ：

```java

public class WebsocketRoutingFilter implements GlobalFilter, Ordered {
    public static final String SEC_WEBSOCKET_PROTOCOL = "Sec-WebSocket-Protocol";
    private final WebSocketClient webSocketClient;
    private final WebSocketService webSocketService;
    public WebsocketRoutingFilter(WebSocketClient webSocketClient) {
        this(webSocketClient, new HandshakeWebSocketService());
    }
    public WebsocketRoutingFilter(WebSocketClient webSocketClient,
            WebSocketService webSocketService) {
        this.webSocketClient = webSocketClient;
        this.webSocketService = webSocketService;
    }

}

```

* webSocketClient 属性，使用的是 ```org.springframework.web.reactive.socket.client.ReactorNettyWebSocketClient``` 实现类。通过该属性，连接后端【被代理】的 WebSocket 服务。
* webSocketService 属性，在 使用的是 ```org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService``` 实现类。通过该属性，处理客户端发起的连接请求( Handshake Request ) 。
* ```#getOrder()``` 方法，代码如下 ：

```java

@Override
public int getOrder() {
    return Ordered.LOWEST_PRECEDENCE;
}

```

* 返回顺序为 Integer.MAX_VALUE 。在 GlobalFilter ，我们列举了所有 GlobalFilter 的顺序。
* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，代码如下 ：

```java

 1: @Override
 2: public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
 3:     // 获得 requestUrl
 4:     URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);
 5:
 6:     // 判断是否能够处理
 7:     String scheme = requestUrl.getScheme();
 8:     if (isAlreadyRouted(exchange) || (!scheme.equals("ws") && !scheme.equals("wss"))) {
 9:         return chain.filter(exchange);
10:     }
11:
12:     // 设置已经路由
13:     setAlreadyRouted(exchange);
14:
15:     // 处理连接请求
16:     return this.webSocketService.handleRequest(exchange,
17:             new ProxyWebSocketHandler(requestUrl, this.webSocketClient, exchange.getRequest().getHeaders()));
18: }

```

* 第 4 行 ：获得 requestUrl 。
* 第 7 至 10 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：
  * ws:// 或者 wss:// 前缀( Scheme ) 。
  * 调用 ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange) 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：

```java

public static boolean isAlreadyRouted(ServerWebExchange exchange) {
    return exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, false);
}

```

* 第 13 行 ：设置该请求已经被处理。代码如下 ：

```java

public static void setAlreadyRouted(ServerWebExchange exchange) {
    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, true);
}

```

* 第 15 至 16 行 ：调用 ```WebSocketService#hanldeRequest(ServerWebExchange, WebSocketHandler)``` 方法，处理客户端发起的连接请求( Handshake Request ) 。这个方法的实现不在本文范围内，但是良心如笔者，大概讲下涉及到的类 ：

1. 主要逻辑在 org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy 类里。
2. 【第一步】 ReactorNettyRequestUpgradeStrategy 调用 reactor.ipc.netty.http.server.HttpServerWSOperations ，处理客户端发起的连接请求。处理成功，告知客户端连接成功。
3. 【第二步】ReactorNettyRequestUpgradeStrategy 调用 org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy 接口的 ```#handle(WebSocketSession)``` 方法，处理客户端 WebSocket Session 。ProxyWebSocketHandler 是 WebSocketHandler 的实现类，在 「3.1 ProxyWebSocketHandler」 来详细解析 ```#handle(WebSocketSession)``` 实现了什么逻辑。

### 4.6.3.1 ProxyWebSocketHandler

* ```org.springframework.cloud.gateway.filter.WebsocketRoutingFilter.ProxyWebSocketHandler``` ，代理后端 WebSocket 服务处理器。构造方法，代码如下 ：

```java

 1: private static class ProxyWebSocketHandler implements WebSocketHandler {
 2:
 3:     private final WebSocketClient client;
 4:     private final URI url;
 5:     private final HttpHeaders headers;
 6:     private final List<String> subProtocols;
 7:
 8:     public ProxyWebSocketHandler(URI url, WebSocketClient client, HttpHeaders headers) {
 9:         this.client = client;
10:         this.url = url;
11:         this.headers = new HttpHeaders();//headers;
12:         //TODO: better strategy to filter these headers?
13:         headers.entrySet().forEach(header -> {
14:             if (!header.getKey().toLowerCase().startsWith("sec-websocket")
15:                     && !header.getKey().equalsIgnoreCase("upgrade")
16:                     && !header.getKey().equalsIgnoreCase("connection")) {
17:                 this.headers.addAll(header.getKey(), header.getValue());
18:             }
19:         });
20:         List<String> protocols = headers.get(SEC_WEBSOCKET_PROTOCOL);
21:         if (protocols != null) {
22:             this.subProtocols = protocols;
23:         } else {
24:             this.subProtocols = Collections.emptyList();
25:         }
26:     }
27: }

```

* client 属性，使用的是 org.springframework.web.reactive.socket.client.ReactorNettyWebSocketClient 实现类。通过该属性，连接后端【被代理】的 WebSocket 服务。
* url 属性，后端【被代理】的 WebSocket 服务的地址。
* header 属性，请求头，在 [《 【计网】HTTP与WebSocket的区别》](http://blog.csdn.net/baiye_xing/article/details/73938360) 有详细解析，包括为什么【第 14 至 18 行】的代码这样处理。
* subProtocols 属性，最终通信使用的协议。
* ```#handle(WebSocketSession)``` 方法，代码如下 ：

```java

 1: @Override
 2: public Mono<Void> handle(WebSocketSession session) {
 3:     // pass headers along so custom headers can be sent through
 4:     return client.execute(url, this.headers, new WebSocketHandler() {
 5:         @Override
 6:         public Mono<Void> handle(WebSocketSession proxySession) {
 7:             // Use retain() for Reactor Netty
 8:             // 转发消息 客户端 =》后端服务
 9:             Mono<Void> proxySessionSend = proxySession
10:                     .send(session.receive().doOnNext(WebSocketMessage::retain));
11:             // 转发消息 后端服务=》客户端
12:             // .log("proxySessionSend", Level.FINE);
13:             Mono<Void> serverSessionSend = session
14:                     .send(proxySession.receive().doOnNext(WebSocketMessage::retain));
15:                     // .log("sessionSend", Level.FINE);
16:
17:             //
18:             return Mono.when(proxySessionSend, serverSessionSend).then();
19:         }
20:
21:         /**
22:          * Copy subProtocols so they are available downstream.
23:          * @return
24:          */
25:         @Override
26:         public List<String> getSubProtocols() {
27:             return ProxyWebSocketHandler.this.subProtocols;
28:         }
29:     });
30: }

```

* 第 6 行 ：调用 WebSocketClient#execute(URI, HttpHeaders, WebSocketHandler) 方法，连接后端【被代理】的 WebSocket 服务。连接成功后，回调 WebSocketHandler 实现的内部类的 #handle(WebSocketSession) 方法。
* WebSocketHandler 实现的内部类
* 第 9 至 10 行 ：转发消息，客户端 => 后端服务。
* 第 13 至 14 行 ：转发消息，后端服务 => 客户端。
* 第 18 行 ：调用 Mono#when() 方法，合并 proxySessionSend / serverSessionSend 两个 Mono 。调用 Mono#then() 方法，参数为空，合并的 Mono 不发射数据出来。RxJava 和 Reactor 类似，可以参考 《ReactiveX文档中文翻译 —— And/Then/When》 学习下 when / and / then 操作符。
* 下图可以帮助理解下这个类的用途 ：

![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_25/01.png)

## 4.7 NettyRoutingFilter

### 4.7.1 概述

>分享 NettyRoutingFilter 的代码实现。

* NettyRoutingFilter ，Netty 路由网关过滤器。其根据 ```http://``` 或 ```https://``` 前缀( Scheme )过滤处理，使用基于 Netty 实现的 HttpClient 请求后端 Http 服务。

* NettyWriteResponseFilter ，与 NettyRoutingFilter 成对使用的网关过滤器。其将 NettyRoutingFilter 请求后端 Http 服务的响应写回客户端。

* 大体流程如下 ：

![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_28/01.png)

* 另外，Spring Cloud Gateway 实现了 ```WebClientHttpRoutingFilter / WebClientWriteResponseFilter``` ，功能上和 ```NettyRoutingFilter / NettyWriteResponseFilter``` 相同，差别在于基于 ```org.springframework.cloud.gateway.filter.WebClient``` 实现的 HttpClient 请求后端 Http 服务。在 WebClientHttpRoutingFilter ，详细解析。

### 4.7.2 NettyRoutingFilter

```org.springframework.cloud.gateway.filter.NettyRoutingFilter``` ，Netty 路由网关过滤器。构造方法，代码如下 ：

```java

public class NettyRoutingFilter implements GlobalFilter, Ordered {
    private final HttpClient httpClient;
    public NettyRoutingFilter(HttpClient httpClient) {
        this.httpClient = httpClient;
    }
}

```

* httpClient 属性，基于 Netty 实现的 HttpClient 。通过该属性，请求后端的 Http 服务。
* ```#getOrder()``` 方法，代码如下 ：

```java

@Override
public int getOrder() {
    return Ordered.LOWEST_PRECEDENCE;
}

```

* 返回顺序为 ```Integer.MAX_VALUE``` 。
* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，代码如下 ：

```java

 1: @Override
 2: public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
 3:     // 获得 requestUrl
 4:     URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);
 5:
 6:     // 判断是否能够处理
 7:     String scheme = requestUrl.getScheme();
 8:     if (isAlreadyRouted(exchange) || (!scheme.equals("http") && !scheme.equals("https"))) {
 9:         return chain.filter(exchange);
10:     }
11:
12:     // 设置已经路由
13:     setAlreadyRouted(exchange);
14:
15:     ServerHttpRequest request = exchange.getRequest();
16:
17:     // Request Method
18:     final HttpMethod method = HttpMethod.valueOf(request.getMethod().toString());
19:
20:     // 获得 url
21:     final String url = requestUrl.toString();
22:
23:     // Request Header
24:     final DefaultHttpHeaders httpHeaders = new DefaultHttpHeaders();
25:     request.getHeaders().forEach(httpHeaders::set);
26:
27:     // 请求
28:     return this.httpClient.request(method, url, req -> {
29:         final HttpClientRequest proxyRequest = req.options(NettyPipeline.SendOptions::flushOnEach)
30:                 .failOnClientError(false) // // 是否请求失败，抛出异常
31:                 .headers(httpHeaders);
32:
33:         // Request Form
34:         if (MediaType.APPLICATION_FORM_URLENCODED.includes(request.getHeaders().getContentType())) {
35:             return exchange.getFormData()
36:                     .flatMap(map -> proxyRequest.sendForm(form -> {
37:                         for (Map.Entry<String, List<String>> entry: map.entrySet()) {
38:                             for (String value : entry.getValue()) {
39:                                 form.attr(entry.getKey(), value);
40:                             }
41:                         }
42:                     }).then())
43:                     .then(chain.filter(exchange));
44:         }
45:
46:         // Request Body
47:         return proxyRequest.sendHeaders() //I shouldn't need this
48:                 .send(request.getBody()
49:                         .map(DataBuffer::asByteBuffer) // Flux<DataBuffer> => ByteBuffer
50:                         .map(Unpooled::wrappedBuffer)); // ByteBuffer => Flux<DataBuffer>
51:     }).doOnNext(res -> {
52:         ServerHttpResponse response = exchange.getResponse();
53:         // Response Header
54:         // put headers and status so filters can modify the response
55:         HttpHeaders headers = new HttpHeaders();
56:         res.responseHeaders().forEach(entry -> headers.add(entry.getKey(), entry.getValue()));
57:         response.getHeaders().putAll(headers);
58:
59:         // Response Status
60:         response.setStatusCode(HttpStatus.valueOf(res.status().code()));
61:
62:         // 设置 Response 到 CLIENT_RESPONSE_ATTR
63:         // Defer committing the response until all route filters have run
64:         // Put client response as ServerWebExchange attribute and write response later NettyWriteResponseFilter
65:         exchange.getAttributes().put(CLIENT_RESPONSE_ATTR, res);
66:     }).then(chain.filter(exchange));
67: }

```

* 第 4 行 ：获得 requestUrl 。
* 第 7 至 10 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：
* ```http://``` 或者 ```https://``` 前缀( Scheme ) 。
* 调用 ```ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange)``` 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：

```java

public static boolean isAlreadyRouted(ServerWebExchange exchange) {
    return exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, false);
}

```

* 第 13 行 ：设置该请求已经被处理。代码如下 ：

```java

public static void setAlreadyRouted(ServerWebExchange exchange) {
    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, true);
}

```

* 第 18 行 ：创建 Netty Request Method 对象。request#getMethod() 返回的不是 io.netty.handler.codec.http.HttpMethod ，所以需要进行转换。
* 第 21 行 ：获得 url 。
* 第 24 至 25 行 ：创建 Netty Request Header 对象( io.netty.handler.codec.http.DefaultHttpHeaders )，将请求的 Header 设置给它。
* 第 28 至 50 行 ：调用 HttpClient#request(HttpMethod, String, Function) 方法，请求后端 Http 服务。
* 第 29 至 31 行 ：创建 Netty Request 对象( reactor.ipc.netty.http.client.HttpClientRequest )。
* 第 29 行 ：TODO 【3024】 NettyPipeline.SendOptions::flushOnEach
* 第 30 行 ：设置请求失败( 后端服务返回响应状体码 >= 400 )时，不抛出异常。相关代码如下 ：

```java

// HttpClientOperations#checkResponseCode(HttpResponse response)
// ... 省略无关代码
if (code >= 400) {
    if (clientError) {
        if (log.isDebugEnabled()) {
            log.debug("{} Received Request Error, stop reading: {}",
                    channel(),
                    response.toString());
        }
        Exception ex = new HttpClientException(uri(), response);
        parentContext().fireContextError(ex);
        receive().subscribe();
        return false;
    }
    return true;
}

```

* 通过设置 clientError = false ，第 51 行可以调用 ```Mono#doNext(Consumer)``` 方法，统一订阅处理返回的 ```reactor.ipc.netty.http.client.HttpClientResponse``` 对象。
* 第 31 行 ：设置 Netty Request 对象的 Header 。
* 第 34 至 44 行 ：【TODO 3025】目前是一个 BUG ，在 2.0.X 版本修复。见 ```FormIntegrationTests#formUrlencodedWorks()``` 单元测试的注释说明。
* 第 47 至 50 行 ：请求后端的 Http 服务。
  * 第 47 行 ：发送请求 Header 。
  * 第 48 至 50 行 ：发送请求 Body 。其中中间的 #map(...) 的过程为 ```Flux<DataBuffer> => ByteBuffer => Flux<DataBuffer>``` 。
* 第 51 至 65 行 ：请求后端 Http 服务完成，将 Netty Response 赋值给响应 response
* 第 53 至 57 行 ：创建 ```org.springframework.http.HttpHeaders``` 对象，将 Netty Response Header 设置给它，而后设置回给响应 response 。
* 第 60 行 ：设置响应 response 的状态码。
* 第 65 行 ：设置 Netty Response 到 ```CLIENT_RESPONSE_ATTR``` 。后续 NettyWriteResponseFilter 将 Netty Response 写回给客户端。
* 第 66 行 ：提交过滤器链继续过滤

### 4.7.3 NettyWriteResponseFilter

```org.springframework.cloud.gateway.filter.NettyWriteResponseFilter``` ，Netty 回写响应网关过滤器。

```#getOrder()``` 方法，代码如下 ：

```java

public static final int WRITE_RESPONSE_FILTER_ORDER = -1;

@Override
public int getOrder() {
    return WRITE_RESPONSE_FILTER_ORDER;
}

```

* 返回顺序为-1

* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，代码如下 ：

```java

 1: @Override
 2: public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
 3:     // NOTICE: nothing in "pre" filter stage as CLIENT_RESPONSE_ATTR is not added
 4:     // until the WebHandler is run
 5:     return chain.filter(exchange).then(Mono.defer(() -> {
 6:         // 获得 Response
 7:         HttpClientResponse clientResponse = exchange.getAttribute(CLIENT_RESPONSE_ATTR);
 8:         // HttpClientResponse clientResponse = getAttribute(exchange, CLIENT_RESPONSE_ATTR, HttpClientResponse.class);
 9:         if (clientResponse == null) {
10:             return Mono.empty();
11:         }
12:         log.trace("NettyWriteResponseFilter start");
13:         ServerHttpResponse response = exchange.getResponse();
14:
15:         // 将 Netty Response 写回给客户端。
16:         NettyDataBufferFactory factory = (NettyDataBufferFactory) response.bufferFactory();
17:         //TODO: what if it's not netty
18:         final Flux<NettyDataBuffer> body = clientResponse.receive()
19:                 .retain() // ByteBufFlux => ByteBufFlux
20:                 .map(factory::wrap); // ByteBufFlux  => Flux<NettyDataBuffer>
21:         return response.writeWith(body);
22:     }));
23: }

```

* 第 5 行 ：调用 ```#then(Mono)``` 方法，实现 After Filter 逻辑。
* 第 7 至 11 行 ：从 ```CLIENT_RESPONSE_ATTR``` 中，获得 Netty Response 。
* 第 15 至 21 行 ：将 Netty Response 写回给客户端。因为 ```org.springframework.http.server.reactive#writeWith(Publisher<? extends DataBuffer>)``` 需要的参数类型是 ```Publisher<? extends DataBuffer>``` ，所以【第 18 至 20 行】的转换过程是 ```ByteBufFlux => Flux<NettyDataBuffer>``` 。
* 第 19 行 ：```TODO 【3024】ByteBufFlux#retain()```
