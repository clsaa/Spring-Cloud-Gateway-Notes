# 4. 过滤器

## 4.1 GatewayFilter一览

### 4.1.1 概述

* 过滤器整体类图如下 ：

![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_01/01.png)

### 4.1.2 GatewyFilter

```org.springframework.cloud.gateway.filter.GatewayFilter``` ，网关过滤器接口，代码如下 ：

```java

public interface GatewayFilter {
    /**
     * Process the Web request and (optionally) delegate to the next
     * {@code WebFilter} through the given {@link GatewayFilterChain}.
     * @param exchange the current server exchange
     * @param chain provides a way to delegate to the next filter
     * @return {@code Mono<Void>} to indicate when request processing is complete
     */
    Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);
}

```

* 从接口方法可以看到，和 javax.servlet.Filter 类似。

* GatewayFilter 有三种类型的子类实现，我们下面每节介绍一种。

#### 4.1.2.1 GatewayFilterFactory 内部类

* 在每个 GatewayFilterFactory 实现类的 ```#apply(Tuple)``` 方法里，都声明了一个实现 GatewayFilter 的内部类，以 ```AddRequestHeaderGatewayFilterFactory``` 的代码举例子 ：

```java

 1: public class AddRequestHeaderGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     @Override
 4:     public List<String> argNames() {
 5:         return Arrays.asList(NAME_KEY, VALUE_KEY);
 6:     }
 7:
 8:     @Override
 9:     public GatewayFilter apply(Tuple args) {
10:         String name = args.getString(NAME_KEY);
11:         String value = args.getString(VALUE_KEY);
12:
13:         return (exchange, chain) -> { // GatewayFilter
14:             ServerHttpRequest request = exchange.getRequest().mutate()
15:                     .header(name, value)
16:                     .build();
17:
18:             return chain.filter(exchange.mutate().request(request).build());
19:         };
20:     }
21: }

```

* 第 13 至 19 行 ：定义了一个 GatewayFilter 内部实现类。

#### 4.1.2.2 OrderedGatewayFilter

```org.springframework.cloud.gateway.filter.OrderedGatewayFilter``` ，有序的网关过滤器实现类。在 FilterChain 里，过滤器数组首先会按照 order 升序排序，按照顺序过滤请求。代码如下 ：

```java

public class OrderedGatewayFilter implements GatewayFilter, Ordered {
    private final GatewayFilter delegate;
    private final int order;
    public OrderedGatewayFilter(GatewayFilter delegate, int order) {
        this.delegate = delegate;
        this.order = order;
    }
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return this.delegate.filter(exchange, chain);
    }
    @Override
    public int getOrder() {
        return this.order;
    }
}

```

* ```delegate``` 属性，委托的 GatewayFilter 。
* ```order``` 属性，顺序。
* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，使用 delegate 过滤请求。

#### 4.1.2.3 GatewayFilterAdapter

```org.springframework.cloud.gateway.handler.FilteringWebHandler.GatewayFilterAdapter``` ，网关过滤器适配器。在 GatewayFilterChain 使用 GatewayFilter 过滤请求，所以通过 GatewayFilterAdapter 将 GlobalFilter 适配成 GatewayFilter 。GatewayFilterAdapter 代码如下 ：

```java

private static class GatewayFilterAdapter implements GatewayFilter {
    private final GlobalFilter delegate;

    public GatewayFilterAdapter(GlobalFilter delegate) {
        this.delegate = delegate;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        return this.delegate.filter(exchange, chain);
    }
}

```

* ```delegate``` 属性，委托的 GlobalFilter 。
* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，使用 delegate 过滤请求。
* 在 FilteringWebHandler 初始化时，将 GlobalFilter 委托成 GatewayFilterAdapter ，代码如下 ：

```java

 1: public class FilteringWebHandler implements WebHandler {
 2:
 3:     /**
 4:      * 全局过滤器
 5:      */
 6:     private final List<GatewayFilter> globalFilters;
 7:
 8:     public FilteringWebHandler(List<GlobalFilter> globalFilters) {
 9:         this.globalFilters = loadFilters(globalFilters);
10:     }
11:
12:     private static List<GatewayFilter> loadFilters(List<GlobalFilter> filters) {
13:         return filters.stream()
14:                 .map(filter -> {
15:                     GatewayFilterAdapter gatewayFilter = new GatewayFilterAdapter(filter);
16:                     if (filter instanceof Ordered) {
17:                         int order = ((Ordered) filter).getOrder();
18:                         return new OrderedGatewayFilter(gatewayFilter, order);
19:                     }
20:                     return gatewayFilter;
21:                 }).collect(Collectors.toList());
22:     }
23: }

```

* 第 16 至 19 行 ：当 GlobalFilter 子类实现了 ```org.springframework.core.Ordered``` 接口，在委托一层 OrderedGatewayFilter 。这样 ```AnnotationAwareOrderComparator#sort(List)``` 方法好排序。
* 第 20 行 ：当 GlobalFilter 子类没有实现了 ```org.springframework.core.Ordered``` 接口，在 ```AnnotationAwareOrderComparator#sort(List)``` 排序时，顺序值为 ```Integer.MAX_VALUE``` 。
* 目前 GlobalFilter 都实现了 ```org.springframework.core.Ordered``` 接口。

### 4.1.3 GlobalFilter

* ```org.springframework.cloud.gateway.filter.GlobalFilter``` ，全局过滤器接口，代码如下 ：

```java

public interface GlobalFilter {
    /**
     * Process the Web request and (optionally) delegate to the next
     * {@code WebFilter} through the given {@link GatewayFilterChain}.
     * @param exchange the current server exchange
     * @param chain provides a way to delegate to the next filter
     * @return {@code Mono<Void>} to indicate when request processing is complete
     */
    Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);
}

```

* GlobalFilter 和 GatewayFilter 的 ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法签名一致。官方说，未来的版本将作出一些调整。
* GlobalFilter 会作用到所有的 Route 上。
* GlobalFilter 实现类如下类图 ：
![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_01/02.png)
* RoutingFilter
  * NettyRoutingFilter
  * WebClientHttpRoutingFilter
  * WebsocketRoutingFilter
  * ForwardRoutingFilter
* 成对的 Filter
  * NettyRoutingFilter / NettyWriteResponseFilter
  * WebClientHttpRoutingFilter / WebClientWriteResponseFilter


### 4.1.4 GatewayFilterChain

```org.springframework.cloud.gateway.filter.GatewayFilterChain``` ，网关过滤器链接口。代码如下 ：

```java

public interface GatewayFilterChain {
    /**
     * Delegate to the next {@code WebFilter} in the chain.
     * @param exchange the current server exchange
     * @return {@code Mono<Void>} to indicate when request handling is complete
     */
    Mono<Void> filter(ServerWebExchange exchange);
}

```

* 从接口方法可以看到，和 javax.servlet.FilterChain 类似。

* ```org.springframework.cloud.gateway.handler.FilteringWebHandler.GatewayFilterAdapter``` ，网关过滤器链默认实现类。代码如下 ：

```java

private static class DefaultGatewayFilterChain implements GatewayFilterChain {
    private int index;
    private final List<GatewayFilter> filters;
    public DefaultGatewayFilterChain(List<GatewayFilter> filters) {
        this.filters = filters;
    }
    @Override
    public Mono<Void> filter(ServerWebExchange exchange) {
        if (this.index < filters.size()) {
            GatewayFilter filter = filters.get(this.index++);
            return filter.filter(exchange, this);
        } else {
            return Mono.empty(); // complete
        }
    }
}

```

## 4.2 GatewayFilterFactory 过滤器工厂

### 4.2.1 概述

![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_05/01.png)

### 4.2.2 Header

>Header 相关的 GatewayFilterFactory 实现类。

#### 4.2.2.1 AddRequestHeaderGatewayFilterFactory

* 用途 ：添加指定请求 Header 为指定值。
* 配置 ：

```yaml

spring:
  cloud:
    gateway:
      routes:
      # =====================================
      - id: add_request_header_route
        uri: http://example.org
        filters:
        - AddRequestHeader=X-Request-Foo, Bar

```

* 代码

```java

 1: public class AddRequestHeaderGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     @Override
 4:     public List<String> argNames() {
 5:         return Arrays.asList(NAME_KEY, VALUE_KEY);
 6:     }
 7:
 8:     @Override
 9:     public GatewayFilter apply(Tuple args) {
10:         String name = args.getString(NAME_KEY);
11:         String value = args.getString(VALUE_KEY);
12:
13:         return (exchange, chain) -> { // GatewayFilter
14:             // 创建新的 ServerHttpRequest
15:             ServerHttpRequest request = exchange.getRequest().mutate()
16:                     .header(name, value)
17:                     .build();
18:
19:             // 创建新的 ServerWebExchange ，提交过滤器链继续过滤
20:             return chain.filter(exchange.mutate().request(request).build());
21:         };
22:     }
23: }

```

* Tuple 参数 ：name / value 。
* 第 14 至 17 行 ：创建新的 ServerHttpRequest 。
* 第 19 至 20 行 ：创建新的 ServerWebExchange ，提交过滤器链继续过滤。

#### 4.2.2.2 RemoveRequestHeaderGatewayFilterFactory

* 类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— RemoveRequestHeader GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#removerequestheader-gatewayfilter-factory) 查看官方文档。

#### 4.2.2.3 AddResponseHeaderGatewayFilterFactory

* 类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— AddResponseHeader GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#addresponseheader-gatewayfilter-factory) 查看官方文档。

#### 4.2.2.4 RemoveResponseHeaderGatewayFilterFactory

类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— RemoveResponseHeader GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#removeresponseheader-gatewayfilter-factory) 查看官方文档。

#### 4.2.2.5 SetResponseHeaderGatewayFilterFactory

类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— SetStatus GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#removeresponseheader-gatewayfilter-factory)  查看官方文档。

#### 4.2.2.6 RemoveNonProxyHeadersGatewayFilterFactory

* 用途 ：移除请求 **Proxy** 相关的 Header 。默认值为 ```[ "Connection", "Keep-Alive", "Proxy-Authenticate", "Proxy-Authorization", "TE", "Trailer", "Transfer-Encoding", "Upgrade" ] ( 参考自 ：https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-14#section-7.1.3 )``` ，可以通过 ```spring.cloud.gateway.filter.remove-non-proxy-headers``` 配置。
* 代码 ：

```java

1: @ConfigurationProperties("spring.cloud.gateway.filter.remove-non-proxy-headers")
 2: public class RemoveNonProxyHeadersGatewayFilterFactory implements GatewayFilterFactory {
 3:
 4:     /**
 5:      * 默认
 6:      */
 7:     public static final String[] DEFAULT_HEADERS_TO_REMOVE = new String[] {"Connection", "Keep-Alive",
 8:             "Proxy-Authenticate", "Proxy-Authorization", "TE", "Trailer", "Transfer-Encoding", "Upgrade"};
 9:
10:     private List<String> headers = Arrays.asList(DEFAULT_HEADERS_TO_REMOVE);
11:
12:     public List<String> getHeaders() {
13:         return headers;
14:     }
15:
16:    public void setHeaders(List<String> headers) {
17:         this.headers = headers;
18:     }
19:
20:     @Override
21:     public GatewayFilter apply(Tuple args) {
22:         //TODO: support filter args
23:
24:         return (exchange, chain) -> {
25:             // 创建新的 ServerHttpRequest
26:             ServerHttpRequest request = exchange.getRequest().mutate()
27:                     .headers(httpHeaders -> {
28:                         for (String header : this.headers) {
29:                             httpHeaders.remove(header); // 移除
30:                         }
31:                     })
32:                     .build();
33:
34:             // 创建新的 ServerWebExchange ，提交过滤器链继续过滤
35:             return chain.filter(exchange.mutate().request(request).build());
36:         };
37:     }
38:

```

#### 4.2.2.7 SecureHeadersGatewayFilterFactory

* 用途 ：添加响应 Secure 相关的 Header 。默认值在 ```org.springframework.cloud.gateway.filter.factory.SecureHeadersProperties``` ，可以通过 ```spring.cloud.gateway.filter.secure-headers``` 配置。
* 代码 ：

```java

 1: public class SecureHeadersGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     public static final String X_XSS_PROTECTION_HEADER = "X-Xss-Protection";
 4:     public static final String STRICT_TRANSPORT_SECURITY_HEADER = "Strict-Transport-Security";
 5:     public static final String X_FRAME_OPTIONS_HEADER = "X-Frame-Options";
 6:     public static final String X_CONTENT_TYPE_OPTIONS_HEADER = "X-Content-Type-Options";
 7:     public static final String REFERRER_POLICY_HEADER = "Referrer-Policy";
 8:     public static final String CONTENT_SECURITY_POLICY_HEADER = "Content-Security-Policy";
 9:     public static final String X_DOWNLOAD_OPTIONS_HEADER = "X-Download-Options";
10:     public static final String X_PERMITTED_CROSS_DOMAIN_POLICIES_HEADER = "X-Permitted-Cross-Domain-Policies";
11:
12:     private final SecureHeadersProperties properties;
13:
14:     public SecureHeadersGatewayFilterFactory(SecureHeadersProperties properties) {
15:         this.properties = properties;
16:     }
17:
18:     @Override
19:     public GatewayFilter apply(Tuple args) {
20:         //TODO: allow args to override properties
21:
22:         return (exchange, chain) -> {
23:             HttpHeaders headers = exchange.getResponse().getHeaders();
24:
25:             //TODO: allow header to be disabled
26:             headers.add(X_XSS_PROTECTION_HEADER, properties.getXssProtectionHeader());
27:             headers.add(STRICT_TRANSPORT_SECURITY_HEADER, properties.getStrictTransportSecurity());
28:             headers.add(X_FRAME_OPTIONS_HEADER, properties.getFrameOptions());
29:             headers.add(X_CONTENT_TYPE_OPTIONS_HEADER, properties.getContentTypeOptions());
30:             headers.add(REFERRER_POLICY_HEADER, properties.getReferrerPolicy());
31:             headers.add(CONTENT_SECURITY_POLICY_HEADER, properties.getContentSecurityPolicy());
32:             headers.add(X_DOWNLOAD_OPTIONS_HEADER, properties.getDownloadOptions());
33:             headers.add(X_PERMITTED_CROSS_DOMAIN_POLICIES_HEADER, properties.getPermittedCrossDomainPolicies());
34:
35:             return chain.filter(exchange);
36:         };
37:     }
38: }

```

*　第 26 至 33 行 ：添加响应 Secure 相关的 Header 。

### 4.2.3 Parameter

> Parameter 相关的 GatewayFilterFactory 实现类。

#### 4.2.3.1 AddRequestParameterGatewayFilterFactory

类似 AddRequestHeaderGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— AddRequestParameter GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#addrequestheader-gatewayfilter-factory) 查看官方文档。

### 4.2.4 Path

>Path 相关的 GatewayFilterFactory 实现类。

#### 4.2.4.1 RewritePathGatewayFilterFactory

* 用途 ：根据配置的正则表达式 regexp ，使用配置的 replacement 重写请求 Path 。从功能目的上类似 《Module ngx_http_rewrite_module》 。
* 配置 ：

```yaml

spring:
  cloud:
    gateway:
      routes:
      # =====================================
      - id: rewritepath_route
        uri: http://example.org
        predicates:
        - Path=/foo/**
        filters:
        - RewritePath=/foo/(?<segment>.*), /$\{segment}

```

* 注意，$\ 用于替代 $ ，避免和 YAML 语法冲突。

```java

 1: public class RewritePathGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     public static final String REGEXP_KEY = "regexp";
 4:     public static final String REPLACEMENT_KEY = "replacement";
 5:
 6:     @Override
 7:     public List<String> argNames() {
 8:         return Arrays.asList(REGEXP_KEY, REPLACEMENT_KEY);
 9:     }
10:
11:     @Override
12:     public GatewayFilter apply(Tuple args) {
13:         final String regex = args.getString(REGEXP_KEY);
14:         // `$\` 用于替代 `$` ，避免和 YAML 语法冲突。
15:         String replacement = args.getString(REPLACEMENT_KEY).replace("$\\", "$");
16:
17:         return (exchange, chain) -> {
18:             ServerHttpRequest req = exchange.getRequest();
19:             // 添加 原始请求URI 到 GATEWAY_ORIGINAL_REQUEST_URL_ATTR
20:             addOriginalRequestUrl(exchange, req.getURI());
21:             // 重写 Path
22:             String path = req.getURI().getPath();
23:             String newPath = path.replaceAll(regex, replacement);
24:
25:             // 创建新的 ServerHttpRequest
26:             ServerHttpRequest request = req.mutate()
27:                     .path(newPath) // 设置 Path
28:                     .build();
29:
30:             // 添加 请求URI 到 GATEWAY_REQUEST_URL_ATTR
31:             exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, request.getURI());
32:
33:             // 创建新的 ServerWebExchange ，提交过滤器链继续过滤
34:             return chain.filter(exchange.mutate().request(request).build());
35:         };
36:     }
37: }

```

* Tuple 参数 ：regexp / replacement 。
* 第 15 行 ：$\ 用于替代 $ ，避免和 YAML 语法冲突。
* 第 20 行 ：调用 ```ServerWebExchangeUtils#addOriginalRequestUrl(...)``` 添加原始请求 URI 到 ```GATEWAY_ORIGINAL_REQUEST_URL_ATTR``` 。代码如下 ：

```java

public static void addOriginalRequestUrl(ServerWebExchange exchange, URI url) {
        exchange.getAttributes().computeIfAbsent(GATEWAY_ORIGINAL_REQUEST_URL_ATTR, s -> new LinkedHashSet<>()); // 数组，考虑多次重写
    LinkedHashSet<URI> uris = exchange.getRequiredAttribute(GATEWAY_ORIGINAL_REQUEST_URL_ATTR);
    uris.add(url);
}

```

* 为什么使用 LinkedHashSet ？因为可以使用 RewritePathGatewayFilterFactory / PrefixPathGatewayFilterFactory 多次重写。

* 第 21 至 23 行 ：重写请求 Path 。
* 第 26 至 28 行 ：创建新的 ServerHttpRequest 。
* 第 31 行 ：添加请求 URI 到 GATEWAY_REQUEST_URL_ATTR 。
* 第 34 行 ：创建新的 ServerWebExchange ，提交过滤器链继续过滤。

#### 4.2.4.2 PrefixPathGatewayFilterFactory

类似 RewritePathGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— PrefixPath GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#setpath-gatewayfilter-factory) 查看官方文档。

#### 4.2.4.3 SetPathGatewayFilterFactory

类似 RewritePathGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— SetPath GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#prefixpath-gatewayfilter-factory) 查看官方文档。

### 4.2.5 Status

>Status 相关的 GatewayFilterFactory 实现类。

#### 4.2.5.1 SetStatusGatewayFilterFactory

类似 RedirectToGatewayFilterFactory ，不重复分享，点击 [《Spring Cloud Gateway —— SetStatus GatewayFilter Factory》](https://github.com/spring-cloud/spring-cloud-gateway/blob/9ffb0f18678460fda9b25c572c12f9054a62ca52/docs/src/main/asciidoc/spring-cloud-gateway.adoc#setstatus-gatewayfilter-factory) 查看官方文档。

### 4.2.6 Redirect

>Redirect 相关的 GatewayFilterFactory 实现类。

#### 4.2.6.1 RedirectToGatewayFilterFactory

用途 ：将响应重定向到指定 URL ，并设置响应状态码为指定 Status 。注意，Status 必须为 3XX 重定向状态码。
配置 ：

```yaml

spring:
  cloud:
    gateway:
      routes:
      # =====================================
      - id: prefixpath_route
        uri: http://example.org
        filters:
        - RedirectTo=302, http://www.iocoder.cn

```

代码 ：

```java

 1: public class RedirectToGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     public static final String STATUS_KEY = "status";
 4:     public static final String URL_KEY = "url";
 5:
 6:     @Override
 7:     public List<String> argNames() {
 8:         return Arrays.asList(STATUS_KEY, URL_KEY);
 9:     }
10:
11:     @Override
12:     public GatewayFilter apply(Tuple args) {
13:         String statusString = args.getRawString(STATUS_KEY);
14:         String urlString = args.getString(URL_KEY);
15:
16:         // 解析 status ，并判断是否是 3XX 重定向状态
17:         final HttpStatus httpStatus = parse(statusString);
18:         Assert.isTrue(httpStatus.is3xxRedirection(), "status must be a 3xx code, but was " + statusString);
19:         // 创建 URL
20:         final URL url;
21:         try {
22:             url = URI.create(urlString).toURL();
23:         } catch (MalformedURLException e) {
24:             throw new IllegalArgumentException("Invalid url " + urlString, e);
25:         }
26:
27:         return (exchange, chain) ->
28:             chain.filter(exchange).then(Mono.defer(() -> { // After Filter
29:                 if (!exchange.getResponse().isCommitted()) {
30:                     // 设置响应 Status
31:                     setResponseStatus(exchange, httpStatus);
32:
33:                     // 设置响应 Header
34:                     final ServerHttpResponse response = exchange.getResponse();
35:                     response.getHeaders().set(HttpHeaders.LOCATION, url.toString());
36:                     return response.setComplete();
37:                 }
38:                 return Mono.empty();
39:             }));
40:     }
41:
42: }

```

* 第 16 至 18 行 ：解析配置的 statusString ，并判断是否是 3XX 重定向状态码。
* 第 19 至 25 行 ：解析配置的 urlString ，创建 URL 。
* 第 28 行 ：调用 ```#then(Mono)``` 方法，实现 After Filter 逻辑。这里和 AddRequestHeaderGatewayFilterFactory 实现的 Before Filter 【方式】不同。
* 第 29 至 37 行 ：若响应未提交，设置响应的状态码、响应的 Header ( Location ) 。
* 第 38 行 ：设置响应已提交。

## 4.3 RouteToRequestUrlFilter

### 4.3.1 概述

>本文主要分享 RouteToRequestUrlFilter 的代码实现。

* RouteToRequestUrlFilter 根据匹配的 Route ，计算请求的地址。注意，**这里的地址指的是 URL ，而不是 URI 。**

### 4.3.2 RouteToRequestUrlFilter

```org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter``` ，代码如下 ：

```java

 1: public class RouteToRequestUrlFilter implements GlobalFilter, Ordered {
 2:
 3:     private static final Log log = LogFactory.getLog(RouteToRequestUrlFilter.class);
 4:     public static final int ROUTE_TO_URL_FILTER_ORDER = 10000;
 5:
 6:     @Override
 7:     public int getOrder() {
 8:         return ROUTE_TO_URL_FILTER_ORDER;
 9:     }
10:
11:     @Override
12:     public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
13:         // 获得 Route
14:         Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);
15:         if (route == null) {
16:             return chain.filter(exchange);
17:         }
18:         log.trace("RouteToRequestUrlFilter start");
19:         // 拼接 requestUrl
20:         URI requestUrl = UriComponentsBuilder.fromHttpRequest(exchange.getRequest())
21:                 .uri(route.getUri())
22:                 .build(true) // encoded=true
23:                 .toUri();
24:         // 设置 requestUrl 到 GATEWAY_REQUEST_URL_ATTR {@link RewritePathGatewayFilterFactory}
25:         exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, requestUrl);
26:         // 提交过滤器链继续过滤
27:         return chain.filter(exchange);
28:     }
29:
30: }

```

* 实现 GlobalFilter 接口。
* ```#getOrder()``` 方法，返回顺序为 10000 。在GlobalFilter ，我们列举了所有 GlobalFilter 的顺序。
* 第 13 至 18 行 ：获得请求匹配的 Route ，在RoutePredicateHandlerMapping 路由匹配有详细解析。
* 第 20 至 23 行 ：拼接 requestUrl 。这里有一点要注意下，如果 Route.uri 属性配置带有 Path ，则会覆盖请求的 Path 。

```yaml

Route.uri    Request.uri    requestUrl
http://bin.org:80    http://127.0.0.1:8080/test/segment    http://httpbin.org:80/123
http://bin.org:80/123    http://127.0.0.1:8080/test/segment    http://httpbin.org:80/test/segment

```

* 为什么会导致覆盖的情况呢 ？答案在 UriComponentsBuilder#uri(URI) 方法，代码如下 ：

```java

 1: public UriComponentsBuilder uri(URI uri) {
 2:     Assert.notNull(uri, "URI must not be null");
 3:     this.scheme = uri.getScheme();
 4:     if (uri.isOpaque()) {
 5:         this.ssp = uri.getRawSchemeSpecificPart();
 6:         resetHierarchicalComponents();
 7:     }
 8:     else {
 9:         if (uri.getRawUserInfo() != null) {
10:             this.userInfo = uri.getRawUserInfo();
11:         }
12:         if (uri.getHost() != null) {
13:             this.host = uri.getHost();
14:         }
15:         if (uri.getPort() != -1) {
16:             this.port = String.valueOf(uri.getPort());
17:         }
18:         if (StringUtils.hasLength(uri.getRawPath())) {
19:             this.pathBuilder = new CompositePathComponentBuilder();
20:             this.pathBuilder.addPath(uri.getRawPath());
21:         }
22:         if (StringUtils.hasLength(uri.getRawQuery())) {
23:             this.queryParams.clear();
24:             query(uri.getRawQuery());
25:         }
26:         resetSchemeSpecificPart();
27:     }
28:     if (uri.getRawFragment() != null) {
29:         this.fragment = uri.getRawFragment();
30:     }
31:     return this;
32: }

```
* 第 18 至 21 行 ：当 uri 参数有 Path 时，新建一个 CompositePathComponentBuilder ，因此原有的 this.pathBuilder 被覆盖了。
* 第 25 行 ：设置 requestUrl 到 GATEWAY_REQUEST_URL_ATTR 。后面 Routing 相关的 GatewayFilter 会通过该属性，发起请求。
* 第 27 行 ：提交过滤器链继续过滤。注意，这里不需要创建新的 ServerWebExchange

## 4.4 LoadBalancerClientFilter

### 4.4.1 概述

>LoadBalancerClientFilter 的代码实现。**LoadBalancerClientFilter 根据 lb:// 前缀过滤处理，使用 serviceId 选择一个服务实例，从而实现负载均衡。**

### 4.4.2 环境搭建

* 请见 (2-路由.md) 2.4.2 环境搭建

### 4.4.3 LoadBalancerClientFilter

* ```org.springframework.cloud.gateway.filter.LoadBalancerClientFilter``` ，代码如下 ：

```java

 1: public class LoadBalancerClientFilter implements GlobalFilter, Ordered {
 2:
 3:     private static final Log log = LogFactory.getLog(LoadBalancerClientFilter.class);
 4:     public static final int LOAD_BALANCER_CLIENT_FILTER_ORDER = 10100;
 5:
 6:     private final LoadBalancerClient loadBalancer;
 7:
 8:     public LoadBalancerClientFilter(LoadBalancerClient loadBalancer) {
 9:         this.loadBalancer = loadBalancer;
10:     }
11:
12:     @Override
13:     public int getOrder() {
14:         return LOAD_BALANCER_CLIENT_FILTER_ORDER;
15:     }
16:
17:     @Override
18:     public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
19:         // 获得 URL
20:         URI url = exchange.getAttribute(GATEWAY_REQUEST_URL_ATTR);
21:         if (url == null || !url.getScheme().equals("lb")) {
22:             return chain.filter(exchange);
23:         }
24:         // 添加 原始请求URI 到 GATEWAY_ORIGINAL_REQUEST_URL_ATTR
25:         //preserve the original url
26:         addOriginalRequestUrl(exchange, url);
27:
28:         log.trace("LoadBalancerClientFilter url before: " + url);
29:
30:         // 获取 服务实例
31:         final ServiceInstance instance = loadBalancer.choose(url.getHost());
32:         if (instance == null) {
33:             throw new NotFoundException("Unable to find instance for " + url.getHost());
34:         }
35:
36:         /*URI uri = exchange.getRequest().getURI();
37:         URI requestUrl = loadBalancer.reconstructURI(instance, uri);*/
38:         //
39:         URI requestUrl = UriComponentsBuilder.fromUri(url)
40:                 .scheme(instance.isSecure()? "https" : "http") //TODO: support websockets
41:                 .host(instance.getHost())
42:                 .port(instance.getPort())
43:                 .build(true)
44:                 .toUri();
45:         log.trace("LoadBalancerClientFilter url chosen: " + requestUrl);
46:
47:         // 添加 请求URI 到 GATEWAY_REQUEST_URL_ATTR
48:         exchange.getAttributes().put(GATEWAY_REQUEST_URL_ATTR, requestUrl);
49:
50:         // 提交过滤器链继续过滤
51:         return chain.filter(exchange);
52:     }
53:
54: }

```

* 第 19 至 23 行 ：获得 URL 。只处理 lb:// 为前缀( Scheme )的地址。
* 第 第 26 行 ：调用 ```ServerWebExchangeUtils#addOriginalRequestUrl(...)``` 添加原始请求 URI 到 GATEWAY_ORIGINAL_REQUEST_URL_ATTR 。代码如下 ：

```java

public static void addOriginalRequestUrl(ServerWebExchange exchange, URI url) {
        exchange.getAttributes().computeIfAbsent(GATEWAY_ORIGINAL_REQUEST_URL_ATTR, s -> new LinkedHashSet<>()); // 数组，考虑多次重写
    LinkedHashSet<URI> uris = exchange.getRequiredAttribute(GATEWAY_ORIGINAL_REQUEST_URL_ATTR);
    uris.add(url);
}

```

* 为什么使用 LinkedHashSet ？因为可以使用 RewritePathGatewayFilterFactory / PrefixPathGatewayFilterFactory 多次重写。
* 第 30 至 34 行 ：调用 ```LoadBalancerClient#choose(String)``` 方法，获得一个服务实例( ServiceInstance ) ，从而实现负载均衡。
* 熟悉 Spring Cloud 的同学都知道，一般情况下 LoadBalancerClient 实现类为 ``org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient`` 。
* 举个 instance 的值例子 ：
![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_15/01.png)
* 第 39 至 45 行 ：创建 requestUrl 。举个例子 ：
![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_15/02.png)
* 第 48 行 ：设置 requestUrl 到 GATEWAY_REQUEST_URL_ATTR 。后面 Routing 相关的 GatewayFilter 会通过该属性，发起请求。
* 第 51 行 ：提交过滤器链继续过滤。注意，这里不需要创建新的 ServerWebExchange

### 4.5 ForwardRoutingFilter

### 4.5.1 概述

>分享 ForwardRoutingFilter 的代码实现。

* RouteToRequestUrlFilter ，转发路由网关过滤器。其根据 forward:// 前缀( Scheme )过滤处理，将请求转发到当前网关实例本地接口。
* 举个例子，配置 RouteDefinition 路由定义如下 ：

```yaml

spring:
  application:
      name: juejin-gateway
  cloud:
    gateway:
      routes:
      # =====================================
      - id: forward_sample
        uri: forward:///globalfilters
        order: 10000
        predicates:
        - Path=/globalfilters
        filters:
        - PrefixPath=/application/gateway

```

* 我们假定网关端口为 8080 。
* 当请求 <http://127.0.0.1:8080/globalfilters> 接口，Spring Cloud Gateway 处理过程如下 ：
  * 匹配到路由 Route (id = forward_sample) 。
  * 配置的 PrefixPathGatewayFilterFactory 将请求改写成 <http://127.0.0.1:8080/application/gateway/globalfilters> 。
  * ForwardRoutingFilter 判断有 forward:// 前缀( Scheme )，过滤处理，将请求转发给 DispatcherHandler 。
  * DispatcherHandler 匹配并转发到当前网关实例本地接口 application/gateway/globalfilters 。
* 为什么需要配置 PrefixPathGatewayFilterFactory ？需要通过 PrefixPathGatewayFilterFactory 将请求重写路径，以匹配本地 API ，否则 DispatcherHandler 转发会失败。
* 另外，RouteToRequestUrlFilter 是 Spring Cloud Gateway 实现的一种路由网关过滤器，目前还提供 WebsocketRoutingFilter / NettyRoutingFilter / WebClientHttpRoutingFilter 。

### 4.5.2 RouteToRequestUrlFilter

* ```org.springframework.cloud.gateway.filter.ForwardRoutingFilter``` ，代码如下 ：

```java

 1: public class ForwardRoutingFilter implements GlobalFilter, Ordered {
 2:
 3:     private static final Log log = LogFactory.getLog(ForwardRoutingFilter.class);
 4:
 5:     private final DispatcherHandler dispatcherHandler;
 6:
 7:     public ForwardRoutingFilter(DispatcherHandler dispatcherHandler) {
 8:         this.dispatcherHandler = dispatcherHandler;
 9:     }
10:
11:     @Override
12:     public int getOrder() {
13:         return Ordered.LOWEST_PRECEDENCE;
14:     }
15:
16:     @Override
17:     public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
18:         // 获得 requestUrl
19:         URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);
20:
21:         // 判断是否能够处理
22:         String scheme = requestUrl.getScheme();
23:         if (isAlreadyRouted(exchange) || !scheme.equals("forward")) {
24:             return chain.filter(exchange);
25:         }
26:
27:         // 设置已经路由
28:         setAlreadyRouted(exchange);
29:
30:         //TODO: translate url?
31:
32:         if (log.isTraceEnabled()) {
33:             log.trace("Forwarding to URI: "+requestUrl);
34:         }
35:
36:         // DispatcherHandler 匹配并转发到当前网关实例本地接口
37:         return this.dispatcherHandler.handle(exchange);
38:     }
39: }

```

* 实现 GlobalFilter 接口。
* ```#getOrder()``` 方法，返回顺序为 ```Integer.MAX_VALUE``` 。在 《Spring-Cloud-Gateway 源码解析 —— 过滤器 (4.1) 之 GatewayFilter 一览》「3. GlobalFilter」 ，我们列举了所有 GlobalFilter 的顺序。
* 第 19 行 ：获得 ```requestUrl``` 。
* 第 22 至 25 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：
* ```forward://``` 前缀( Scheme ) 。
* 调用 ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange) 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：

```java

public static boolean isAlreadyRouted(ServerWebExchange exchange) {
    return exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, false);
}

```

* 第 28 行 ：设置该请求已经被处理。代码如下 ：

```java

public static void setAlreadyRouted(ServerWebExchange exchange) {
    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, true);
}

```

* 第 37 行 ：将请求转发给 DispatcherHandler 。DispatcherHandler 匹配并转发到当前网关实例本地接口。

## 4.6 WebSocketRoutingFilter

### 4.6.1 概述

>主要分享 WebsocketRoutingFilter 的代码实现。

* WebsocketRoutingFilter ，Websocket 路由网关过滤器。其根据 ```ws:// / wss:// 前缀( Scheme )```过滤处理，代理后端 Websocket 服务，提供给客户端连接。如下图 ：

![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_25/01.png)

* 目前一个 RouteDefinition 只能指定一个后端 WebSocket 服务。官方正在计划在 LoadBalancerClientFilter 上实现 Websocket 的负载均衡功能。也就说，未来一个 RouteDefinition 能够指定多个后端 WebSocket 服务。

* Websocket 的 RouteDefinition 配置如下 ：

```yaml

cloud:
    gateway:
      routes:
      - id: websocket_test
        uri: ws://localhost:9000
        order: 8000
        predicates:
        - Path=/echo

```

* uri 使用 ws:// 或者 wss:// 为前缀。

### 4.6.2 环境搭建

>在解析源码之前，我们先以 wscat 搭建一个 WebSocket 服务。

* 第一步，安装 wscat 。

```javascript

npm install -g wscat

```

* 第二步，启动 wscat 。

```javascript

wscat --listen 9000

```

* 第三步，连接 wscat 。

```javascript

wscat --listen 9000

```

* 第四步，配置 RouteDefinition ，并启动 Spring Cloud Gateway 。

```yaml

cloud:
    gateway:
      routes:
      - id: websocket_test
        uri: ws://localhost:9000
        order: 8000
        predicates:
        - Path=/echo

```

* 第五步，通过 Gateway 连接 wscat 。

```javascript

wscat --connect ws://localhost:8080/echo

```
大功告成。

>注意，wscat 同一时间仅允许一个客户端连接。

### 4.6.3 WebsocketRoutingFilter

* ```org.springframework.cloud.gateway.filter.WebsocketRoutingFilter``` ，Websocket 路由网关过滤器。

* 构造方法，代码如下 ：

```java

public class WebsocketRoutingFilter implements GlobalFilter, Ordered {
    public static final String SEC_WEBSOCKET_PROTOCOL = "Sec-WebSocket-Protocol";
    private final WebSocketClient webSocketClient;
    private final WebSocketService webSocketService;
    public WebsocketRoutingFilter(WebSocketClient webSocketClient) {
        this(webSocketClient, new HandshakeWebSocketService());
    }
    public WebsocketRoutingFilter(WebSocketClient webSocketClient,
            WebSocketService webSocketService) {
        this.webSocketClient = webSocketClient;
        this.webSocketService = webSocketService;
    }

}

```

* webSocketClient 属性，使用的是 ```org.springframework.web.reactive.socket.client.ReactorNettyWebSocketClient``` 实现类。通过该属性，连接后端【被代理】的 WebSocket 服务。
* webSocketService 属性，在 使用的是 ```org.springframework.web.reactive.socket.server.support.HandshakeWebSocketService``` 实现类。通过该属性，处理客户端发起的连接请求( Handshake Request ) 。
* ```#getOrder()``` 方法，代码如下 ：

```java

@Override
public int getOrder() {
    return Ordered.LOWEST_PRECEDENCE;
}

```

* 返回顺序为 Integer.MAX_VALUE 。在 GlobalFilter ，我们列举了所有 GlobalFilter 的顺序。
* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，代码如下 ：

```java

 1: @Override
 2: public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
 3:     // 获得 requestUrl
 4:     URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);
 5:
 6:     // 判断是否能够处理
 7:     String scheme = requestUrl.getScheme();
 8:     if (isAlreadyRouted(exchange) || (!scheme.equals("ws") && !scheme.equals("wss"))) {
 9:         return chain.filter(exchange);
10:     }
11:
12:     // 设置已经路由
13:     setAlreadyRouted(exchange);
14:
15:     // 处理连接请求
16:     return this.webSocketService.handleRequest(exchange,
17:             new ProxyWebSocketHandler(requestUrl, this.webSocketClient, exchange.getRequest().getHeaders()));
18: }

```

* 第 4 行 ：获得 requestUrl 。
* 第 7 至 10 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：
  * ws:// 或者 wss:// 前缀( Scheme ) 。
  * 调用 ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange) 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：

```java

public static boolean isAlreadyRouted(ServerWebExchange exchange) {
    return exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, false);
}

```

* 第 13 行 ：设置该请求已经被处理。代码如下 ：

```java

public static void setAlreadyRouted(ServerWebExchange exchange) {
    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, true);
}

```

* 第 15 至 16 行 ：调用 ```WebSocketService#hanldeRequest(ServerWebExchange, WebSocketHandler)``` 方法，处理客户端发起的连接请求( Handshake Request ) 。这个方法的实现不在本文范围内，但是良心如笔者，大概讲下涉及到的类 ：

1. 主要逻辑在 org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy 类里。
2. 【第一步】 ReactorNettyRequestUpgradeStrategy 调用 reactor.ipc.netty.http.server.HttpServerWSOperations ，处理客户端发起的连接请求。处理成功，告知客户端连接成功。
3. 【第二步】ReactorNettyRequestUpgradeStrategy 调用 org.springframework.web.reactive.socket.server.upgrade.ReactorNettyRequestUpgradeStrategy 接口的 ```#handle(WebSocketSession)``` 方法，处理客户端 WebSocket Session 。ProxyWebSocketHandler 是 WebSocketHandler 的实现类，在 「3.1 ProxyWebSocketHandler」 来详细解析 ```#handle(WebSocketSession)``` 实现了什么逻辑。

### 4.6.3.1 ProxyWebSocketHandler

* ```org.springframework.cloud.gateway.filter.WebsocketRoutingFilter.ProxyWebSocketHandler``` ，代理后端 WebSocket 服务处理器。构造方法，代码如下 ：

```java

 1: private static class ProxyWebSocketHandler implements WebSocketHandler {
 2:
 3:     private final WebSocketClient client;
 4:     private final URI url;
 5:     private final HttpHeaders headers;
 6:     private final List<String> subProtocols;
 7:
 8:     public ProxyWebSocketHandler(URI url, WebSocketClient client, HttpHeaders headers) {
 9:         this.client = client;
10:         this.url = url;
11:         this.headers = new HttpHeaders();//headers;
12:         //TODO: better strategy to filter these headers?
13:         headers.entrySet().forEach(header -> {
14:             if (!header.getKey().toLowerCase().startsWith("sec-websocket")
15:                     && !header.getKey().equalsIgnoreCase("upgrade")
16:                     && !header.getKey().equalsIgnoreCase("connection")) {
17:                 this.headers.addAll(header.getKey(), header.getValue());
18:             }
19:         });
20:         List<String> protocols = headers.get(SEC_WEBSOCKET_PROTOCOL);
21:         if (protocols != null) {
22:             this.subProtocols = protocols;
23:         } else {
24:             this.subProtocols = Collections.emptyList();
25:         }
26:     }
27: }

```

* client 属性，使用的是 org.springframework.web.reactive.socket.client.ReactorNettyWebSocketClient 实现类。通过该属性，连接后端【被代理】的 WebSocket 服务。
* url 属性，后端【被代理】的 WebSocket 服务的地址。
* header 属性，请求头，在 [《 【计网】HTTP与WebSocket的区别》](http://blog.csdn.net/baiye_xing/article/details/73938360) 有详细解析，包括为什么【第 14 至 18 行】的代码这样处理。
* subProtocols 属性，最终通信使用的协议。
* ```#handle(WebSocketSession)``` 方法，代码如下 ：

```java

 1: @Override
 2: public Mono<Void> handle(WebSocketSession session) {
 3:     // pass headers along so custom headers can be sent through
 4:     return client.execute(url, this.headers, new WebSocketHandler() {
 5:         @Override
 6:         public Mono<Void> handle(WebSocketSession proxySession) {
 7:             // Use retain() for Reactor Netty
 8:             // 转发消息 客户端 =》后端服务
 9:             Mono<Void> proxySessionSend = proxySession
10:                     .send(session.receive().doOnNext(WebSocketMessage::retain));
11:             // 转发消息 后端服务=》客户端
12:             // .log("proxySessionSend", Level.FINE);
13:             Mono<Void> serverSessionSend = session
14:                     .send(proxySession.receive().doOnNext(WebSocketMessage::retain));
15:                     // .log("sessionSend", Level.FINE);
16:
17:             //
18:             return Mono.when(proxySessionSend, serverSessionSend).then();
19:         }
20:
21:         /**
22:          * Copy subProtocols so they are available downstream.
23:          * @return
24:          */
25:         @Override
26:         public List<String> getSubProtocols() {
27:             return ProxyWebSocketHandler.this.subProtocols;
28:         }
29:     });
30: }

```

* 第 6 行 ：调用 WebSocketClient#execute(URI, HttpHeaders, WebSocketHandler) 方法，连接后端【被代理】的 WebSocket 服务。连接成功后，回调 WebSocketHandler 实现的内部类的 #handle(WebSocketSession) 方法。
* WebSocketHandler 实现的内部类
* 第 9 至 10 行 ：转发消息，客户端 => 后端服务。
* 第 13 至 14 行 ：转发消息，后端服务 => 客户端。
* 第 18 行 ：调用 Mono#when() 方法，合并 proxySessionSend / serverSessionSend 两个 Mono 。调用 Mono#then() 方法，参数为空，合并的 Mono 不发射数据出来。RxJava 和 Reactor 类似，可以参考 《ReactiveX文档中文翻译 —— And/Then/When》 学习下 when / and / then 操作符。
* 下图可以帮助理解下这个类的用途 ：

![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_25/01.png)

## 4.7 NettyRoutingFilter

### 4.7.1 概述

>分享 NettyRoutingFilter 的代码实现。

* NettyRoutingFilter ，Netty 路由网关过滤器。其根据 ```http://``` 或 ```https://``` 前缀( Scheme )过滤处理，使用基于 Netty 实现的 HttpClient 请求后端 Http 服务。

* NettyWriteResponseFilter ，与 NettyRoutingFilter 成对使用的网关过滤器。其将 NettyRoutingFilter 请求后端 Http 服务的响应写回客户端。

* 大体流程如下 ：

![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_03_28/01.png)

* 另外，Spring Cloud Gateway 实现了 ```WebClientHttpRoutingFilter / WebClientWriteResponseFilter``` ，功能上和 ```NettyRoutingFilter / NettyWriteResponseFilter``` 相同，差别在于基于 ```org.springframework.cloud.gateway.filter.WebClient``` 实现的 HttpClient 请求后端 Http 服务。在 WebClientHttpRoutingFilter ，详细解析。

### 4.7.2 NettyRoutingFilter

```org.springframework.cloud.gateway.filter.NettyRoutingFilter``` ，Netty 路由网关过滤器。构造方法，代码如下 ：

```java

public class NettyRoutingFilter implements GlobalFilter, Ordered {
    private final HttpClient httpClient;
    public NettyRoutingFilter(HttpClient httpClient) {
        this.httpClient = httpClient;
    }
}

```

* httpClient 属性，基于 Netty 实现的 HttpClient 。通过该属性，请求后端的 Http 服务。
* ```#getOrder()``` 方法，代码如下 ：

```java

@Override
public int getOrder() {
    return Ordered.LOWEST_PRECEDENCE;
}

```

* 返回顺序为 ```Integer.MAX_VALUE``` 。
* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，代码如下 ：

```java

 1: @Override
 2: public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
 3:     // 获得 requestUrl
 4:     URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);
 5:
 6:     // 判断是否能够处理
 7:     String scheme = requestUrl.getScheme();
 8:     if (isAlreadyRouted(exchange) || (!scheme.equals("http") && !scheme.equals("https"))) {
 9:         return chain.filter(exchange);
10:     }
11:
12:     // 设置已经路由
13:     setAlreadyRouted(exchange);
14:
15:     ServerHttpRequest request = exchange.getRequest();
16:
17:     // Request Method
18:     final HttpMethod method = HttpMethod.valueOf(request.getMethod().toString());
19:
20:     // 获得 url
21:     final String url = requestUrl.toString();
22:
23:     // Request Header
24:     final DefaultHttpHeaders httpHeaders = new DefaultHttpHeaders();
25:     request.getHeaders().forEach(httpHeaders::set);
26:
27:     // 请求
28:     return this.httpClient.request(method, url, req -> {
29:         final HttpClientRequest proxyRequest = req.options(NettyPipeline.SendOptions::flushOnEach)
30:                 .failOnClientError(false) // // 是否请求失败，抛出异常
31:                 .headers(httpHeaders);
32:
33:         // Request Form
34:         if (MediaType.APPLICATION_FORM_URLENCODED.includes(request.getHeaders().getContentType())) {
35:             return exchange.getFormData()
36:                     .flatMap(map -> proxyRequest.sendForm(form -> {
37:                         for (Map.Entry<String, List<String>> entry: map.entrySet()) {
38:                             for (String value : entry.getValue()) {
39:                                 form.attr(entry.getKey(), value);
40:                             }
41:                         }
42:                     }).then())
43:                     .then(chain.filter(exchange));
44:         }
45:
46:         // Request Body
47:         return proxyRequest.sendHeaders() //I shouldn't need this
48:                 .send(request.getBody()
49:                         .map(DataBuffer::asByteBuffer) // Flux<DataBuffer> => ByteBuffer
50:                         .map(Unpooled::wrappedBuffer)); // ByteBuffer => Flux<DataBuffer>
51:     }).doOnNext(res -> {
52:         ServerHttpResponse response = exchange.getResponse();
53:         // Response Header
54:         // put headers and status so filters can modify the response
55:         HttpHeaders headers = new HttpHeaders();
56:         res.responseHeaders().forEach(entry -> headers.add(entry.getKey(), entry.getValue()));
57:         response.getHeaders().putAll(headers);
58:
59:         // Response Status
60:         response.setStatusCode(HttpStatus.valueOf(res.status().code()));
61:
62:         // 设置 Response 到 CLIENT_RESPONSE_ATTR
63:         // Defer committing the response until all route filters have run
64:         // Put client response as ServerWebExchange attribute and write response later NettyWriteResponseFilter
65:         exchange.getAttributes().put(CLIENT_RESPONSE_ATTR, res);
66:     }).then(chain.filter(exchange));
67: }

```

* 第 4 行 ：获得 requestUrl 。
* 第 7 至 10 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：
* ```http://``` 或者 ```https://``` 前缀( Scheme ) 。
* 调用 ```ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange)``` 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：

```java

public static boolean isAlreadyRouted(ServerWebExchange exchange) {
    return exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, false);
}

```

* 第 13 行 ：设置该请求已经被处理。代码如下 ：

```java

public static void setAlreadyRouted(ServerWebExchange exchange) {
    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, true);
}

```

* 第 18 行 ：创建 Netty Request Method 对象。request#getMethod() 返回的不是 io.netty.handler.codec.http.HttpMethod ，所以需要进行转换。
* 第 21 行 ：获得 url 。
* 第 24 至 25 行 ：创建 Netty Request Header 对象( io.netty.handler.codec.http.DefaultHttpHeaders )，将请求的 Header 设置给它。
* 第 28 至 50 行 ：调用 HttpClient#request(HttpMethod, String, Function) 方法，请求后端 Http 服务。
* 第 29 至 31 行 ：创建 Netty Request 对象( reactor.ipc.netty.http.client.HttpClientRequest )。
* 第 29 行 ：TODO 【3024】 NettyPipeline.SendOptions::flushOnEach
* 第 30 行 ：设置请求失败( 后端服务返回响应状体码 >= 400 )时，不抛出异常。相关代码如下 ：

```java

// HttpClientOperations#checkResponseCode(HttpResponse response)
// ... 省略无关代码
if (code >= 400) {
    if (clientError) {
        if (log.isDebugEnabled()) {
            log.debug("{} Received Request Error, stop reading: {}",
                    channel(),
                    response.toString());
        }
        Exception ex = new HttpClientException(uri(), response);
        parentContext().fireContextError(ex);
        receive().subscribe();
        return false;
    }
    return true;
}

```

* 通过设置 clientError = false ，第 51 行可以调用 ```Mono#doNext(Consumer)``` 方法，统一订阅处理返回的 ```reactor.ipc.netty.http.client.HttpClientResponse``` 对象。
* 第 31 行 ：设置 Netty Request 对象的 Header 。
* 第 34 至 44 行 ：【TODO 3025】目前是一个 BUG ，在 2.0.X 版本修复。见 ```FormIntegrationTests#formUrlencodedWorks()``` 单元测试的注释说明。
* 第 47 至 50 行 ：请求后端的 Http 服务。
  * 第 47 行 ：发送请求 Header 。
  * 第 48 至 50 行 ：发送请求 Body 。其中中间的 #map(...) 的过程为 ```Flux<DataBuffer> => ByteBuffer => Flux<DataBuffer>``` 。
* 第 51 至 65 行 ：请求后端 Http 服务完成，将 Netty Response 赋值给响应 response
* 第 53 至 57 行 ：创建 ```org.springframework.http.HttpHeaders``` 对象，将 Netty Response Header 设置给它，而后设置回给响应 response 。
* 第 60 行 ：设置响应 response 的状态码。
* 第 65 行 ：设置 Netty Response 到 ```CLIENT_RESPONSE_ATTR``` 。后续 NettyWriteResponseFilter 将 Netty Response 写回给客户端。
* 第 66 行 ：提交过滤器链继续过滤

### 4.7.3 NettyWriteResponseFilter

```org.springframework.cloud.gateway.filter.NettyWriteResponseFilter``` ，Netty 回写响应网关过滤器。

```#getOrder()``` 方法，代码如下 ：

```java

public static final int WRITE_RESPONSE_FILTER_ORDER = -1;

@Override
public int getOrder() {
    return WRITE_RESPONSE_FILTER_ORDER;
}

```

* 返回顺序为-1

* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，代码如下 ：

```java

 1: @Override
 2: public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
 3:     // NOTICE: nothing in "pre" filter stage as CLIENT_RESPONSE_ATTR is not added
 4:     // until the WebHandler is run
 5:     return chain.filter(exchange).then(Mono.defer(() -> {
 6:         // 获得 Response
 7:         HttpClientResponse clientResponse = exchange.getAttribute(CLIENT_RESPONSE_ATTR);
 8:         // HttpClientResponse clientResponse = getAttribute(exchange, CLIENT_RESPONSE_ATTR, HttpClientResponse.class);
 9:         if (clientResponse == null) {
10:             return Mono.empty();
11:         }
12:         log.trace("NettyWriteResponseFilter start");
13:         ServerHttpResponse response = exchange.getResponse();
14:
15:         // 将 Netty Response 写回给客户端。
16:         NettyDataBufferFactory factory = (NettyDataBufferFactory) response.bufferFactory();
17:         //TODO: what if it's not netty
18:         final Flux<NettyDataBuffer> body = clientResponse.receive()
19:                 .retain() // ByteBufFlux => ByteBufFlux
20:                 .map(factory::wrap); // ByteBufFlux  => Flux<NettyDataBuffer>
21:         return response.writeWith(body);
22:     }));
23: }

```

* 第 5 行 ：调用 ```#then(Mono)``` 方法，实现 After Filter 逻辑。
* 第 7 至 11 行 ：从 ```CLIENT_RESPONSE_ATTR``` 中，获得 Netty Response 。
* 第 15 至 21 行 ：将 Netty Response 写回给客户端。因为 ```org.springframework.http.server.reactive#writeWith(Publisher<? extends DataBuffer>)``` 需要的参数类型是 ```Publisher<? extends DataBuffer>``` ，所以【第 18 至 20 行】的转换过程是 ```ByteBufFlux => Flux<NettyDataBuffer>``` 。
* 第 19 行 ：```TODO 【3024】ByteBufFlux#retain()```

## 4.8 WebClientHttpRoutingFilter

### 4.8.1 概述

>分享 WebClientHttpRoutingFilter 的代码实现。

* WebClientHttpRoutingFilter ，Http 路由网关过滤器。其根据 ```http:// 或 https:// 前缀( Scheme )```过滤处理，使用基于 ```org.springframework.cloud.gateway.filter.WebClient``` 实现的 HttpClient 请求后端 Http 服务。

* WebClientWriteResponseFilter ，与 WebClientHttpRoutingFilter 成对使用的网关过滤器。其将 WebClientWriteResponseFilter 请求后端 Http 服务的响应写回客户端。

* 大体流程如下 ：

![image](http://www.iocoder.cn/images/Spring-Cloud-Gateway/2020_04_01/01.png)

### 4.8.2 环境配置

* 目前 WebClientHttpRoutingFilter / WebClientWriteResponseFilter 处于实验阶段，建议等正式发布在使用。

* 第一步，在 NettyConfiguration 注释掉 ```#routingFilter(...)``` 和 ```#nettyWriteResponseFilter()``` 两个 Bean 方法。
* 第二步，在 GatewayAutoConfiguration 打开 ```#webClientHttpRoutingFilter()``` 和 ```#webClientWriteResponseFilter()``` 两个 Bean 方法。
* 第三步，配置完成，启动 Spring Cloud Gateway 。

### 4.8.3 WebClientHttpRoutingFilter

* ```org.springframework.cloud.gateway.filter.WebClientHttpRoutingFilter``` ，Http 路由网关过滤器。
* 构造方法，代码如下 ：

```java

public class WebClientHttpRoutingFilter implements GlobalFilter, Ordered {
    private final WebClient webClient;
    public WebClientHttpRoutingFilter(WebClient webClient) {
        this.webClient = webClient;
    }
}

```

* webClient 属性，默认情况下，使用```org.springframework.web.reactive.function.client.DefaultWebClient``` 实现类。通过该属性，请求后端的 Http 服务。
* ```#getOrder()``` 方法，代码如下 ：

```java

@Override
public int getOrder() {
    return Ordered.LOWEST_PRECEDENCE;
}

```

* 返回顺序为 ```Integer.MAX_VALUE``` 。
* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，代码如下 ：

```java

 1: @Override
 2: public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
 3:     // 获得 requestUrl
 4:     URI requestUrl = exchange.getRequiredAttribute(GATEWAY_REQUEST_URL_ATTR);
 5:
 6:     // 判断是否能够处理
 7:     String scheme = requestUrl.getScheme();
 8:     if (isAlreadyRouted(exchange) || (!scheme.equals("http") && !scheme.equals("https"))) {
 9:         return chain.filter(exchange);
10:     }
11:
12:     // 设置已经路由
13:     setAlreadyRouted(exchange);
14:
15:     ServerHttpRequest request = exchange.getRequest();
16:
17:     //TODO: support forms
18:     // Request Method
19:     HttpMethod method = request.getMethod();
20:
21:     // Request
22:     RequestBodySpec bodySpec = this.webClient.method(method)
23:             .uri(requestUrl)
24:             .headers(httpHeaders -> {
25:                 httpHeaders.addAll(request.getHeaders());
26:                 httpHeaders.remove(HttpHeaders.HOST);
27:             });
28:
29:     // Request Body
30:     RequestHeadersSpec<?> headersSpec;
31:     if (requiresBody(method)) {
32:         headersSpec = bodySpec.body(BodyInserters.fromDataBuffers(request.getBody()));
33:     } else {
34:         headersSpec = bodySpec;
35:     }
36:
37:     return headersSpec.exchange()
38:             // .log("webClient route")
39:             .flatMap(res -> {
40:                 ServerHttpResponse response = exchange.getResponse();
41:
42:                 // Response Header
43:                 response.getHeaders().putAll(res.headers().asHttpHeaders());
44:
45:                 // Response Status
46:                 response.setStatusCode(res.statusCode());
47:
48:                 // 设置 Response 到 CLIENT_RESPONSE_ATTR
49:                 // Defer committing the response until all route filters have run
50:                 // Put client response as ServerWebExchange attribute and write response later NettyWriteResponseFilter
51:                 exchange.getAttributes().put(CLIENT_RESPONSE_ATTR, res);
52:                 return chain.filter(exchange);
53:             });
54: }

```

* 第 4 行 ：获得 requestUrl 。
* 第 7 至 10 行 ：判断 ForwardRoutingFilter 是否能够处理该请求，需要满足两个条件 ：```http:// 或者 https:// 前缀( Scheme )``` 。调用 ```ServerWebExchangeUtils#isAlreadyRouted(ServerWebExchange)``` 方法，判断该请求暂未被其他 Routing 网关处理。代码如下 ：

```java

public static boolean isAlreadyRouted(ServerWebExchange exchange) {
    return exchange.getAttributeOrDefault(GATEWAY_ALREADY_ROUTED_ATTR, false);
}

```

* 第 13 行 ：设置该请求已经被处理。代码如下 ：

```java

public static void setAlreadyRouted(ServerWebExchange exchange) {
    exchange.getAttributes().put(GATEWAY_ALREADY_ROUTED_ATTR, true);
}

```

* 第 17 行 ：TODO 【3025】 目前暂不支持 forms 参数
* 第 22 至 35 行 ：创建向后端服务的请求。
  * 第 22 行 ：设置 Method 属性。
  * 第 24 至 27 行 ：设置 Header 属性。
  * 第 30 至 35 行 ：设置 Body 属性。
* 第 37 行 ：发起向后端服务的请求。
* 第 40 至 53 行 ：处理返回自后端服务的相应。
  * 第 43 行 ：设置 response 的 Header 属性。
  * 第 46 行 ：设置 response 的 Status 属性。
  * 第 51 行 ：设置 res 到 CLIENT_RESPONSE_ATTR 。后续 WebClientWriteResponseFilter 将响应写回给客户端。
  * 第 52 行 ：提交过滤器链继续过滤。

### 4.8.4 WebClientWriteResponseFilter

* ```org.springframework.cloud.gateway.filter.WebClientWriteResponseFilter``` ，Http 回写响应网关过滤器。
* ```#getOrder()``` 方法，代码如下 ：

```java

public static final int WRITE_RESPONSE_FILTER_ORDER = -1;

@Override
public int getOrder() {
    return WRITE_RESPONSE_FILTER_ORDER;
}

```

* 返回顺序为 -1 。
* ```#filter(ServerWebExchange, GatewayFilterChain)``` 方法，代码如下 ：

```java

 1: @Override
 2: public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
 3:     // NOTICE: nothing in "pre" filter stage as CLIENT_RESPONSE_ATTR is not added
 4:     // until the WebHandler is run
 5:     return chain.filter(exchange).then(Mono.defer(() -> {
 6:         // 获得 Response
 7:         ClientResponse clientResponse = exchange.getAttribute(CLIENT_RESPONSE_ATTR);
 8:         if (clientResponse == null) {
 9:             return Mono.empty();
10:         }
11:         log.trace("WebClientWriteResponseFilter start");
12:         ServerHttpResponse response = exchange.getResponse();
13:
14:         return response.writeWith(clientResponse.body(BodyExtractors.toDataBuffers())).log("webClient response");
15:     }));
16: }

```

* 第 5 行 ：调用 ```#then(Mono)``` 方法，实现 After Filter 逻辑。
* 第 7 至 11 行 ：从```CLIENT_RESPONSE_ATTR``` 中，获得 ClientResponse 。
* 第 14 行 ：将 ClientResponse 写回给客户端。

### 4.8.5 和 NettyRoutingFilter 对比

>NettyRoutingFilter / NettyWriteResponseFilter 和 WebClientHttpRoutingFilter / WebClientHttpRoutingFilter 实现一样的功能。

## 4.9 HystrixGatewayFilterFactory 熔断

### 4.9.1 概述

>分享 HystrixGatewayFilterFactory 的代码实现。

* Spring Cloud Gateway 提供了多种 GatewayFilterFactory 的实现，而 HystrixGatewayFilterFactory 也是其中的一种。
* 通过 HystrixGatewayFilterFactory ，可以创建 HystrixGatewayFilter ( 实际是内部匿名类，为了表述方便，下面继续这么称呼 ) 。
* HystrixGatewayFilter 使用 Hystrix ，实现基于 Route 级别的熔断功能。

### 4.9.2 环境搭建

* 第一步，以 ```spring-cloud-gateway-sample``` 项目为基础，在 pom.xml 文件添加依赖库。

```xml

<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
</dependency>

```

* 第二步，在 ```application.yml``` 配置一个 RouteDefinition 。

```yaml

spring:
  cloud:
    gateway:
      routes:
      # =====================================
      - id: default_path_to_httpbin
        uri: http://127.0.0.1:8081
        order: 10000
        predicates:
        - Path=/**
        filters:
        - Hystrix=myCommandName

```

* ```- Hystrix=myCommandName ，配置 HystrixGatewayFilterFactory``` ，并以 myCommandName 为 Hystrix Command 名字。

* 第三步，配置完成，启动 spring-cloud-gateway-sample 项目。

### 4.9.3 HystrixGatewayFilterFactory

* ```org.springframework.cloud.gateway.filter.factory.HystrixGatewayFilterFactory``` ，熔断网关过滤器工厂。代码如下 ：

```java

 1: public class HystrixGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     @Override
 4:     public List<String> argNames() {
 5:         return Arrays.asList(NAME_KEY);
 6:     }
 7:
 8:     @Override
 9:     public GatewayFilter apply(Tuple args) {
10:         //TODO: if no name is supplied, generate one from command id (useful for default filter)
11:         final String commandName = args.getString(NAME_KEY);
12:         final HystrixCommandGroupKey groupKey = HystrixCommandGroupKey.Factory.asKey(getClass().getSimpleName());
13:         final HystrixCommandKey commandKey = HystrixCommandKey.Factory.asKey(commandName);
14:
15:         final HystrixObservableCommand.Setter setter = HystrixObservableCommand.Setter
16:                 .withGroupKey(groupKey)
17:                 .andCommandKey(commandKey);
18:
19:         return (exchange, chain) -> {
20:             RouteHystrixCommand command = new RouteHystrixCommand(setter, exchange, chain);
21:
22:             return Mono.create(s -> {
23:                 // 使用 Hystrix Command Observable 订阅
24:                 Subscription sub = command.toObservable().subscribe(s::success, s::error, s::success);
25:                 // Mono 取消时，取消 Hystrix Command Observable 的订阅，结束 Hystrix Command 的执行
26:                 s.onCancel(sub::unsubscribe);
27:             }).onErrorResume((Function<Throwable, Mono<Void>>) throwable -> {
28:                 if (throwable instanceof HystrixRuntimeException) {
29:                     HystrixRuntimeException e = (HystrixRuntimeException) throwable;
30:                     if (e.getFailureType() == TIMEOUT) { //TODO: optionally set status
31:                         setResponseStatus(exchange, HttpStatus.GATEWAY_TIMEOUT);
32:                         return exchange.getResponse().setComplete();
33:                     }
34:                 }
35:                 return Mono.empty();
36:             }).then();
37:         };
38:     }
39: }

```

* ```#argNames()``` 方法，定义了 Tuple 参数的 Key 为 name 。
* ```#apply()``` 方法，创建 HystrixGatewayFilter 对象。
* 第 11 行 ：从 Tuple 参数获得 Hystrix Command 名字，例如上面举例的 RouteDefinition 时，commandName = myCommandName 。
* 第 12 行 ：创建 Hystrix Command 分组 Key 为 HystrixGatewayFilterFactory 。
* 第 13 行 ：创建 Hystrix Command Key 为 commandName 。
* 第 15 至 17 行 ：创建 HystrixObservableCommand.Setter 对象。
* 第 19 至 37 行 ：创建 HystrixGatewayFilter 对象并返回。
* 第 20 行 ：创建 RouteHystrixCommand 对象。代码如下 ：

```java

private class RouteHystrixCommand extends HystrixObservableCommand<Void> {
    private final ServerWebExchange exchange;
    private final GatewayFilterChain chain;
    RouteHystrixCommand(Setter setter, ServerWebExchange exchange, GatewayFilterChain chain) {
        super(setter);
        this.exchange = exchange;
        this.chain = chain;
    }
    @Override
    protected Observable<Void> construct() {
        return RxReactiveStreams.toObservable(this.chain.filter(this.exchange));
    }
}

```

* 第 22 至 26 行 ：调用 ```Mono#create(Consumer<MonoSink<T>>)``` 方法，创建 Mono 对象。点击 传送门 查看该方法详细说明。因为 Hystrix 基于 RxJava ，而 GatewayFilter 基于 Reactor ( Mono 是其内部的一个类 )，通过这个方法，实现订阅的适配。未来，会实现 HystrixMonoCommand 替换 HystrixObservableCommand ，从而统一订阅，去除适配代码。
  * 第 24 行 ：1）调用```RouteHystrixCommand#toObservable()```方法，内部会调用 ```RouteHystrixCommand#construct()``` 方法，获得执行 ```this.chain.filter(this.exchange)``` 的 Observable 。2）订阅 Observable ：成功或完成时，调用 ```Mono#success(Object)``` 方法，目前创建的 Mono 上没有相关的订阅；异常时，调用 ```Mono#error(Object)``` 方法，目前创建的 Mono 上调用 ```Mongo#onErrorResume(Function<Throwable, Mono<Void>>))``` 方法，进行订阅。
  * 第 26 行 ：Mono 取消时，取消 Hystrix Command Observable 的订阅，结束 Hystrix Command 的执行。
* 第 27 至 34 行 ：当 Hystrix Command 执行超时时，设置响应 504 状态码，并回写客户端响应```( exchange.getResponse().setComplete() )``` 。
* 第 35 行 ：当 Hystrix Command 发生其他异常时，例如断路器打开，返回 ```Mono.empty()``` ，最终返回客户端 200 状态码，内容为空。
* 第 36 行 ：调用 ```Mono#then()``` 方法，参数为空，返回空 Mono ，不再向后发射数据。

### 4.9.4 注意事项

1. 目前 Hystrix Command 执行超时时，返回客户端 504 状态码，如果使用 JSON 格式作为数据返回，则需要修改下该 HystrixGatewayFilter 的代码实现。
2. Hystrix 配置参数，目前只能全局配置，例如说 Hystrix 执行超时时间，配置如下 ：
3. 当 Hystrix 熔断时，最终返回客户端 200 状态码，内容为空，此处建议该 HystrixGatewayFilter 的代码实现。

```yaml

hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 10000

```

* 如果想实现 Route / URL 级别的 Hystrix 配置参数，则需要修改下该 HystrixGatewayFilter 的代码实现。
* [《Hystrix —— Configuration》](https://github.com/Netflix/Hystrix/wiki/Configuration#contents) ，Hystrix 配置项，需要自取。

## 4.10 RequestRateLimiterGatewayFilterFactory 请求限流

### 4.10.1 概述

>RequestRateLimiterGatewayFilterFactory 的代码实现。

* Spring Cloud Gateway 提供了多种 GatewayFilterFactory 的实现，而 ```RequestRateLimiterGatewayFilterFactory``` 也是其中的一种。

* 通过 ```RequestRateLimiterGatewayFilterFactory``` ，可以创建 ```RequestRateLimiterGatewayFilter``` ( 实际是内部匿名类，为了表述方便，下面继续这么称呼 ) 。

* RequestRateLimiterGatewayFilter 使用 ```Redis + Lua``` 实现分布式限流。而限流的粒度，例如 ```URL / 用户 / IP``` 等，通过 ```org.springframework.cloud.gateway.filter.ratelimit.KeyResolver```实现类决定，在KeyResolver详细解析。

### 4.10.2 环境搭建

* 第一步，以 ```spring-cloud-gateway-sample``` 项目为基础，在 ```pom.xml``` 文件添加依赖库。

```xml

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
</dependency>

```

* 第二步，在 ```application.yml``` 配置一个 RouteDefinition 。
  * ```- RequestRateLimiter=10, 20, #{@principalNameKeyResolver}``` ，配置 ```RequestRateLimiterGatewayFilterFactory``` 。
    * 默认情况下，基于令牌桶算法实现限流。
    * 第一个参数，```burstCapacity``` ，令牌桶上限 。
    * 第二个参数，```replenishRate``` ，令牌桶填充平均速率，单位：秒。
    * 第三个参数，```keyResolver``` ，限流键解析器 Bean 对象名字，根据 ```#{@beanName}``` ，使用 SpEL 表达式，从 Spring 容器中获取 Bean 对象，详细参见 ```RouteDefinitionRouteLocator#getTuple(ArgumentHints, Map<String, String>, SpelExpressionParser, BeanFactory)``` 处的代码。另外，这里有一个 BUG ：在 YAML 里，```#```代表注释，所以第三个参数无法正确被读取，需要等待官方修复。如果比较着急使用，可以考虑将此处的 ```#``` 修改成 ```\#``` ，并修改部分相关代码以解决该 BUG 。

```yaml

spring:
  cloud:
    gateway:
      routes:
      # =====================================
      - id: default_path_to_httpbin
        uri: http://127.0.0.1:8081
        order: 10000
        predicates:
        - Path=/**
        filters:
        - RequestRateLimiter=10, 20, #{@principalNameKeyResolver}

```

* 第三步，配置完成，启动 ```spring-cloud-gateway-sample``` 项目。

### 4.10.3 RequestRateLimiterGatewayFilterFactory

* ```org.springframework.cloud.gateway.filter.factory.RequestRateLimiterGatewayFilterFactory``` ，请求限流网关过滤器工厂类。代码如下 ：

```java

 1: public class RequestRateLimiterGatewayFilterFactory implements GatewayFilterFactory {
 2:
 3:     public static final String KEY_RESOLVER_KEY = "keyResolver";
 4:
 5:     private final RateLimiter rateLimiter;
 6:     private final KeyResolver defaultKeyResolver;
 7:
 8:     public RequestRateLimiterGatewayFilterFactory(RateLimiter rateLimiter,
 9:             KeyResolver defaultKeyResolver) {
10:         this.rateLimiter = rateLimiter;
11:         this.defaultKeyResolver = defaultKeyResolver;
12:     }
13:
14:     @Override
15:     public List<String> argNames() {
16:         return Arrays.asList(
17:                 RedisRateLimiter.REPLENISH_RATE_KEY,
18:                 RedisRateLimiter.BURST_CAPACITY_KEY,
19:                 KEY_RESOLVER_KEY
20:         );
21:     }
22:
23:     @Override
24:     public boolean validateArgs() {
25:          return false;
26:     }
27:
28:     @SuppressWarnings("unchecked")
29:     @Override
30:     public GatewayFilter apply(Tuple args) {
31:         validateMin(2, args);
32:
33:         // 获得 KeyResolver
34:         KeyResolver keyResolver;
35:         if (args.hasFieldName(KEY_RESOLVER_KEY)) {
36:             keyResolver = args.getValue(KEY_RESOLVER_KEY, KeyResolver.class);
37:         } else {
38:             keyResolver = defaultKeyResolver;
39:         }
40:
41:         return (exchange, chain) -> keyResolver.resolve(exchange).flatMap(key ->
42:             // TODO: if key is empty?
43:             rateLimiter.isAllowed(key, args).flatMap(response -> {
44:                 // TODO: set some headers for rate, tokens left
45:
46:                 // 允许访问
47:                 if (response.isAllowed()) {
48:                     return chain.filter(exchange);
49:                 }
50:
51:                 // 被限流，不允许访问
52:                 exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
53:                 return exchange.getResponse().setComplete();
54:             }));
55:     }
56:
57: }

```

* ```rateLimiter``` 属性，限流器。默认情况下，使用 RedisRateLimiter 。
* ```defaultKeyResolver``` 属性，默认限流键解析器。默认情况下，使用 PrincipalNameKeyResolver 。
* ```#argNames()``` 方法，定义了 Tuple 参数的 Key 为 ```replenishRate / burstCapacity / keyResolver``` 。
* ```#validateArgs()``` 方法，定义在 ```RouteDefinitionRouteLocator#getTuple(ArgumentHints, Map<String, String>, SpelExpressionParser, BeanFactory)``` 无需校验 Tuple 结果。因为 keyResolver 非必填项，在 #apply() 方法，创建 ```RequestRateLimiterGatewayFilter``` 时校验。
* ```#apply()``` 方法，创建 ```RequestRateLimiterGatewayFilter``` 对象。
* 第 31 行 ：校验 Tuple 参数至少有两个元素，即 ```replenishRate 和 burstCapacity``` 。而 ```keyResolver``` 是选填，为空时，使用默认值 ```defaultKeyResolver``` 。
* 第 34 至 39 行 ：获得 ```keyResolver``` 。通过它，获得请求的限流键，例如URL / 用户 / IP 等。
* 第 41 至 54 行 ：创建 ```RequestRateLimiterGatewayFilter``` 对象并返回。
* 第 41 行 ：调用 ```KeyResolver#resolve(ServerWebExchange)``` 方法，获得请求的限流键。
  * 注意下，这里未处理限流键为空的情况( TODO: if key is empty? )。所以，当限流键为空时，过滤器链不会继续向下执行，也就是说，不会请求后端 Http / Websocket 服务，并且最终返回客户端 200 状态码，内容为空。
* 第 43 至 54 行 ：调用 ```RateLimiter#isAllowed(ServerWebExchange, Tuple)``` 方法，判断是否被限流。
  * 第 47 至 49 行 ：未被限流，允许访问，提交过滤器链继续过滤。
  * 第 52 至 53 行 ：被限流， 不允许访问，设置响应 429 状态码，并回写客户端响应( ```exchange.getResponse().setComplete()``` ) 。

### 4.10.4 KeyResolver

* ```org.springframework.cloud.gateway.filter.ratelimit.KeyResolver``` ，请求键解析器接口。代码如下 ：

```java

public interface KeyResolver {
    Mono<String> resolve(ServerWebExchange exchange);
}

```

* KeyResolver#resolve(ServerWebExchange) 方法，获得请求的限流键。
* 通过实现 KeyResolver 接口，实现获得不同的请求的限流键，例如URL / 用户 / IP 等。
* 目前版本，Spring Cloud Gateway 提供的 KeyResolver 实现类只有 PrincipalNameKeyResolver 。据官方说法，在未来的里程碑版本中，将会有一些 KeyResolver 具体实现类。

### 4.10.4.1 PrincipalNameKeyResolver

```org.springframework.cloud.gateway.filter.ratelimit.PrincipalNameKeyResolver``` ，使用请求认证的 ```java.security.Principal``` 作为限流键。代码如下 ：

```java

public class PrincipalNameKeyResolver implements KeyResolver {
    public static final String BEAN_NAME = "principalNameKeyResolver";
    @Override
    public Mono<String> resolve(ServerWebExchange exchange) {
        return exchange.getPrincipal().map(Principal::getName).switchIfEmpty(Mono.empty());
    }
}

```

### 4.10.4.2 自定义 KeyResolver

* 通过实现 KeyResolver 接口，实现自定义 KeyResolver 。下面我们实现一个使用请求 IP 作为限流键的 KeyResolver 。

* 第一步，创建 RemoteAddrKeyResolver 类，代码如下 ：

```java

public class RemoteAddrKeyResolver implements KeyResolver {
    public static final String BEAN_NAME = "remoteAddrKeyResolver";
    @Override
    public Mono<String> resolve(ServerWebExchange exchange) {
        return Mono.just(exchange.getRequest().getRemoteAddress().getAddress().getHostAddress());
    }
}

```

* 第二步，配置 RemoteAddrKeyResolver Bean 对象，代码如下 ：

```java

@Bean(name = RemoteAddrKeyResolver.BEAN_NAME)
@ConditionalOnBean(RateLimiter.class)
public RemoteAddrKeyResolver remoteAddrKeyResolver() {
    return new RemoteAddrKeyResolver();
}

```

* 第三步，配置 RouteDefinition 路由配置，配置如下 ：

```yaml

spring:
  cloud:
    gateway:
      routes:
      # =====================================
      - id: default_path_to_httpbin
        uri: http://127.0.0.1:8081
        order: 10000
        predicates:
        - Path=/**
        filters:
        - RequestRateLimiter=10, 20, #{@remoteAddrKeyResolver}

```

* 第四步，大功告成，启动 Spring Cloud Gateway 即可。

### 4.10.5 RateLimiter

* ```org.springframework.cloud.gateway.filter.ratelimit.RateLimiter``` ，限流器接口。代码如下 ：

```java

public interface RateLimiter {
    Mono<Response> isAllowed(String id, Tuple args);
}

```

* ```#isAllowed(String id, Tuple args)``` 方法，判断是否被限流。
* Response 类，代码如下 ：

```java

class Response {
    /**
     * 是否允许访问( 未被限流 )
     */
    private final boolean allowed;
    /**
     * 令牌桶剩余数量
     */
    private final long tokensRemaining;
    public Response(boolean allowed, long tokensRemaining) {
        this.allowed = allowed;
        this.tokensRemaining = tokensRemaining;
    }
}

```

### 4.10.5.1 GatewayRedisAutoConfiguration

* ```org.springframework.cloud.gateway.config.GatewayRedisAutoConfiguration``` ，Redis 相关配置类，代码如下 ：

```java

 1: @Configuration
 2: @AutoConfigureAfter(RedisReactiveAutoConfiguration.class)
 3: @AutoConfigureBefore(GatewayAutoConfiguration.class)
 4: @ConditionalOnBean(ReactiveRedisTemplate.class)
 5: @ConditionalOnClass({RedisTemplate.class, DispatcherHandler.class})
 6: class GatewayRedisAutoConfiguration {
 7:
 8:     @Bean
 9:     @SuppressWarnings("unchecked")
10:     public RedisScript redisRequestRateLimiterScript() {
11:         DefaultRedisScript redisScript = new DefaultRedisScript<>();
12:         redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource("META-INF/scripts/request_rate_limiter.lua")));
13:         redisScript.setResultType(List.class);
14:         return redisScript;
15:     }
16:
17:     @Bean
18:     //TODO: replace with ReactiveStringRedisTemplate in future
19:     public ReactiveRedisTemplate<String, String> stringReactiveRedisTemplate(
20:             ReactiveRedisConnectionFactory reactiveRedisConnectionFactory,
21:             ResourceLoader resourceLoader) {
22:         RedisSerializer<String> serializer = new StringRedisSerializer();
23:         RedisSerializationContext<String , String> serializationContext = RedisSerializationContext
24:                 .<String, String>newSerializationContext()
25:                 .key(serializer)
26:                 .value(serializer)
27:                 .hashKey(serializer)
28:                 .hashValue(serializer)
29:                 .build();
30:         return new ReactiveRedisTemplate<>(reactiveRedisConnectionFactory,
31:                 serializationContext);
32:     }
33:
34:     @Bean
35:     public RedisRateLimiter redisRateLimiter(ReactiveRedisTemplate<String, String> redisTemplate,
36:                                              @Qualifier("redisRequestRateLimiterScript") RedisScript<List<Long>> redisScript) {
37:         return new RedisRateLimiter(redisTemplate, redisScript);
38:     }
39:
40: }

```

* 第 8 至 15 行 ：创建 ```org.springframework.data.redis.core.script.RedisScript``` Bean 对象，加载 ```META-INF/scripts/request_rate_limiter.lua``` 路径下的 Redis Lua 脚本。该脚本使用 Redis 基于令牌桶算法实现限流。在本文 「Redis Lua 脚本」 详细解析。
* 第 17 至 32 行 ：创建 ```org.springframework.data.redis.core.ReactiveRedisTemplate Bean``` 对象。
* 第 34 至 38 行 ：使用 RedisScript 和 ReactiveRedisTemplate Bean 对象，创建 RedisRateLimiter Bean 对象。

### 4.10.5.2 RedisRateLimiter

* ```org.springframework.cloud.gateway.filter.ratelimit.RedisRateLimiter``` ，基于 Redis 的分布式限流器实现类。
* 构造方法，代码如下 ：

```java

public class RedisRateLimiter implements RateLimiter {
    public static final String REPLENISH_RATE_KEY = "replenishRate";
    public static final String BURST_CAPACITY_KEY = "burstCapacity";
    private final ReactiveRedisTemplate<String, String> redisTemplate;
    private final RedisScript<List<Long>> script;
    public RedisRateLimiter(ReactiveRedisTemplate<String, String> redisTemplate,
            RedisScript<List<Long>> script) {
        this.redisTemplate = redisTemplate;
        this.script = script;
    }
}

```

* ```redisTemplate``` 属性，RedisTemplate 。
* ```script``` 属性，Lua 脚本。
* ```#isAllowed(id, Tuple)``` ，代码如下 ：

```java

 1: public Mono<Response> isAllowed(String id, Tuple args) {
 2:     // How many requests per second do you want a user to be allowed to do?
 3:     int replenishRate = args.getInt(REPLENISH_RATE_KEY);
 4:
 5:     // How much bursting do you want to allow?
 6:     int burstCapacity;
 7:     if (args.hasFieldName(BURST_CAPACITY_KEY)) {
 8:         burstCapacity = args.getInt(BURST_CAPACITY_KEY);
 9:     } else {
10:         burstCapacity = 0;
11:     }
12:
13:     try {
14:         // Make a unique key per user.
15:         String prefix = "request_rate_limiter." + id;
16:
17:         // You need two Redis keys for Token Bucket.
18:         List<String> keys = Arrays.asList(prefix + ".tokens", prefix + ".timestamp");
19:
20:         // The arguments to the LUA script. time() returns unixtime in seconds.
21:         List<String> scriptArgs = Arrays.asList(replenishRate + "", burstCapacity + "",
22:                  Instant.now().getEpochSecond() + "", "1");
23:         // allowed, tokens_left = redis.eval(SCRIPT, keys, args)
24:         Flux<List<Long>> flux = this.redisTemplate.execute(this.script, keys, scriptArgs);
25:         // .log("redisratelimiter", Level.FINER);
26:         return flux
27:                 // Throwable => Flux.just(Arrays.asList(1L, -1L)) 。
28:                 .onErrorResume(throwable -> Flux.just(Arrays.asList(1L, -1L)))
29:                 // Flux<List<Long>> => Mono<List<Long>>
30:                 .reduce(new ArrayList<Long>(), (longs, l) -> {
31:                     longs.addAll(l);
32:                     return longs;
33:                 })
34:                 // Mono<List<Long>> => Mono<Response>
35:                 .map(results -> {
36:                     boolean allowed = results.get(0) == 1L;
37:                     Long tokensLeft = results.get(1);
38:
39:                     Response response = new Response(allowed, tokensLeft);
40:
41:                     if (log.isDebugEnabled()) {
42:                         log.debug("response: " + response);
43:                     }
44:                     return response;
45:                 });
46:     }
47:     catch (Exception e) {
48:         /*
49:          * We don't want a hard dependency on Redis to allow traffic. Make sure to set
50:          * an alert so you know if this is happening too much. Stripe's observed
51:          * failure rate is 0.01%.
52:          */
53:         log.error("Error determining if user allowed from redis", e);
54:     }
55:     return Mono.just(new Response(true, -1));
56: }

```

* id 方法参数，令牌桶编号。一个令牌桶编号对应令牌桶。在本文场景中为请求限流键。
* 第 3 行 ：获得 burstCapacity 令牌桶上限。
* 第 5 至 11 行 ：获得 replenishRate ，令牌桶填充平均速率，单位：秒。
* 第 15 行 ：获得令牌桶前缀，request_rate_limiter.${id} 。
* 第 18 行 ：获得令牌桶键数组 ：
  * request_rate_limiter.${id}.tokens ：令牌桶剩余令牌数。
  * request_rate_limiter.${id}.timestamp ：令牌桶最后填充令牌时间，单位：秒。
* 第 21 至 22 行 ：获得 Lua 脚本参数 ：
  * 第一个参数 ：replenishRate 。
  * 第二个参数 ：burstCapacity 。
  * 第三个参数 ：得到从 1970-01-01 00:00:00 开始的秒数。为什么在 Java 代码里获取，而不使用 Lua 在 Reids 里获取？
  * 第四个参数 ：消耗令牌数量，默认 1 。

>FROM 《亿级流量网站架构核心技术》因为 Redis 的限制（ Lua中有写操作不能使用带随机性质的读操作，如TIME ）不能在 Redis Lua中 使用 TIME 获取时间戳，因此只好从应用获取然后传入，在某些极端情况下（机器时钟不准的情况下），限流会存在一些小问题。


* 第 24 行 ：调用 ReactiveRedisTemplate#execute(RedisScript<T>, List<K>, List<?>) 方法，执行 Redis Lua 脚本，获取令牌。返回结果为 [是否获取令牌成功, 剩余令牌数] ，其中，1 代表获取令牌成功，0 代表令牌获取失败。
* 第 25 行 ：当 Redis Lua 脚本过程中发生异常，忽略异常，返回 Flux.just(Arrays.asList(1L, -1L)) ，即认为获取令牌成功。为什么？在 Redis 发生故障时，我们不希望限流器对 Reids 是强依赖，并且 Redis 发生故障的概率本身就很低。
* 第 30 至 33 行 ：调用 ```Flux#reduce(A, BiFunction<A, ? super T, A>)``` 方法，将 Flux<List<Long>> 转换成 ```Mono<List<Long>>``` 。因为 ReactiveRedisTemplate#execute(RedisScript<T>, List<K>, List<?>) 方法的执行结果为 Flux ( 多次 )，实际在当前场景里，自行 Redis Lua 脚本只会返回一次数组，所以转换成 Mono (一次)。
* 第 35 至 45 行 ：调用 ```Mono#map(Function<? super T, ? extends R>)``` 方法，将 Mono<List<Long>> => Mono<Response> 。
* 第 47 至 55 行 ：当【第 15 至 24 行】代码部分执行发生异常时，例如 Redis 挂了，返回 Flux.just(Arrays.asList(1L, -1L)) ，即认为获取令牌成功。

### 4.10.5.3 Redis Lua 脚本

```META-INF/scripts/request_rate_limiter.lua``` ，Redis Lua 脚本，实现基于令牌桶算法实现限流。代码如下 ：

```lua

 1: local tokens_key = KEYS[1]
 2: local timestamp_key = KEYS[2]
 3:
 4: local rate = tonumber(ARGV[1])
 5: local capacity = tonumber(ARGV[2])
 6: local now = tonumber(ARGV[3])
 7: local requested = tonumber(ARGV[4])
 8:
 9: local fill_time = capacity/rate
10: local ttl = math.floor(fill_time*2)
11:
12: local last_tokens = tonumber(redis.call("get", tokens_key))
13: if last_tokens == nil then
14:   last_tokens = capacity
15: end
16:
17: local last_refreshed = tonumber(redis.call("get", timestamp_key))
18: if last_refreshed == nil then
19:   last_refreshed = 0
20: end
21:
22: local delta = math.max(0, now-last_refreshed)
23: local filled_tokens = math.min(capacity, last_tokens+(delta*rate))
24: local allowed = filled_tokens >= requested
25: local new_tokens = filled_tokens
26: local allowed_num = 0
27: if allowed then
28:   new_tokens = filled_tokens - requested
29:   allowed_num = 1
30: end
31:
32: redis.call("setex", tokens_key, ttl, new_tokens)
33: redis.call("setex", timestamp_key, ttl, now)
34:
35: return { allowed_num, new_tokens }

```

* 第 1 至 2 行 ：KEYS 方法参数 ：
  * 第一个参数 ：request_rate_limiter.${id}.tokens ，令牌桶剩余令牌数。
  * 第二个参数 ：request_rate_limiter.${id}.timestamp ，令牌桶最后填充令牌时间，单位：秒。
* 第 4 至 7 行 ：ARGV 方法参数 ：
  * 第一个参数 ：replenishRate 。
  * 第二个参数 ：burstCapacity 。
  * 第三个参数 ：得到从 1970-01-01 00:00:00 开始的秒数。
  * 第四个参数 ：消耗令牌数量，默认 1 。
* 第 9 行 ：计算令牌桶填充满令牌需要多久时间，单位：秒。
* 第 10 行 ：计算 request_rate_limiter.${id}.tokens / request_rate_limiter.${id}.timestamp 的 ttl 。* 2 保证时间充足。
* 第 12 至 20 行 ：调用 get 命令，获得令牌桶剩余令牌数( last_tokens ) ，令牌桶最后填充令牌时间(last_refreshed) 。
* 第 22 至 23 行 ：填充令牌，计算新的令牌桶剩余令牌数( filled_tokens )。填充不超过令牌桶令牌上限。
* 第 24 至 30 行 ：获取令牌是否成功。
  * 若成功，令牌桶剩余令牌数(new_tokens) 减消耗令牌数( requested )，并设置获取成功( allowed_num = 1 ) 。
  * 若失败，设置获取失败( allowed_num = 0 ) 。
* 第 32 至 33 行 ：设置令牌桶剩余令牌数( new_tokens ) ，令牌桶最后填充令牌时间(now) 。
* 第 35 行 ：返回数组结果，[是否获取令牌成功, 剩余令牌数] 。

>Redis Lua 脚本不会有并发问题么？FROM 《亿级流量网站架构核心技术》因 Redis 是单线程模型，因此是线程安全的。